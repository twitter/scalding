/**
 * Generated by Scrooge
 *   version: ?
 *   rev: ?
 *   built at: ?
 */
package com.twitter.scalding.commons.macros.scalathrift

import com.twitter.scrooge.{ ThriftStruct, ThriftStructCodec3, ThriftStructFieldInfo, ThriftUnion, TFieldBlob }
import org.apache.thrift.protocol._
import java.nio.ByteBuffer
import java.util.Arrays
import scala.collection.immutable.{ Map => immutable$Map }
import scala.collection.mutable.{
  ArrayBuffer => mutable$ArrayBuffer,
  Buffer => mutable$Buffer,
  HashMap => mutable$HashMap,
  HashSet => mutable$HashSet
}
import scala.collection.{ Map, Set }

@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
sealed trait TestUnion extends ThriftUnion with ThriftStruct

private object TestUnionDecoder {
  def apply(_iprot: TProtocol, newUnknown: TFieldBlob => TestUnion): TestUnion = {
    var _result: TestUnion = null
    _iprot.readStructBegin()
    val _field = _iprot.readFieldBegin()
    _field.id match {
      case 1 => { /* a_i32_list */
        _field.`type` match {
          case TType.LIST => {
            _result = TestUnion.AI32List({
              val _list = _iprot.readListBegin()
              if (_list.size == 0) {
                _iprot.readListEnd()
                Nil
              } else {
                val _rv = new mutable$ArrayBuffer[Int](_list.size)
                var _i = 0
                while (_i < _list.size) {
                  _rv += {
                    _iprot.readI32()

                  }
                  _i += 1
                }
                _iprot.readListEnd()
                _rv
              }
            })
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      }
      case 2 => { /* a_double_set */
        _field.`type` match {
          case TType.SET => {
            _result = TestUnion.ADoubleSet({
              val _set = _iprot.readSetBegin()
              if (_set.size == 0) {
                _iprot.readSetEnd()
                Set.empty[Double]
              } else {
                val _rv = new mutable$HashSet[Double]
                var _i = 0
                while (_i < _set.size) {
                  _rv += {
                    _iprot.readDouble()

                  }
                  _i += 1
                }
                _iprot.readSetEnd()
                _rv
              }
            })
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      }
      case 3 => { /* a_struct */
        _field.`type` match {
          case TType.STRUCT => {
            _result = TestUnion.AStruct({
              com.twitter.scalding.commons.macros.scalathrift.TestStruct.decode(_iprot)
            })
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      }
      case _ =>
        if (_field.`type` != TType.STOP) {
          _result = newUnknown(TFieldBlob.read(_field, _iprot))
        } else {
          TProtocolUtil.skip(_iprot, _field.`type`)
        }
    }
    if (_field.`type` != TType.STOP) {
      _iprot.readFieldEnd()
      var _done = false
      var _moreThanOne = false
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP)
          _done = true
        else {
          _moreThanOne = true
          TProtocolUtil.skip(_iprot, _field.`type`)
          _iprot.readFieldEnd()
        }
      }
      if (_moreThanOne) {
        _iprot.readStructEnd()
        throw new TProtocolException("Cannot read a TUnion with more than one set value!")
      }
    }
    _iprot.readStructEnd()
    if (_result == null)
      throw new TProtocolException("Cannot read a TUnion with no set value!")
    _result
  }
}

object TestUnionAliases {
  type AI32ListAlias = Seq[Int]

  def withoutPassthroughFields_AI32List(obj: TestUnion.AI32List): TestUnion.AI32List = {
    val field = obj.a_i32_list
    TestUnion.AI32List(
      field.map { field =>
        field
      })
  }

  val AI32ListDefaultValue = Seq[Int]()
  val AI32ListKeyTypeManifest = None
  val AI32ListValueTypeManifest = Some(implicitly[Manifest[Int]])
  type ADoubleSetAlias = Set[Double]

  def withoutPassthroughFields_ADoubleSet(obj: TestUnion.ADoubleSet): TestUnion.ADoubleSet = {
    val field = obj.a_double_set
    TestUnion.ADoubleSet(
      field.map { field =>
        field
      })
  }

  val ADoubleSetDefaultValue = Set[Double]()
  val ADoubleSetKeyTypeManifest = None
  val ADoubleSetValueTypeManifest = Some(implicitly[Manifest[Double]])
  type AStructAlias = com.twitter.scalding.commons.macros.scalathrift.TestStruct

  def withoutPassthroughFields_AStruct(obj: TestUnion.AStruct): TestUnion.AStruct = {
    val field = obj.a_struct
    TestUnion.AStruct(
      TestStruct.withoutPassthroughFields(field))
  }

  val AStructKeyTypeManifest = None
  val AStructValueTypeManifest = None
}

@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
object TestUnion extends ThriftStructCodec3[TestUnion] {
  val Union = new TStruct("TestUnion")
  val AI32ListField = new TField("a_i32_list", TType.LIST, 1)
  val AI32ListFieldManifest = implicitly[Manifest[AI32List]]
  val ADoubleSetField = new TField("a_double_set", TType.SET, 2)
  val ADoubleSetFieldManifest = implicitly[Manifest[ADoubleSet]]
  val AStructField = new TField("a_struct", TType.STRUCT, 3)
  val AStructFieldManifest = implicitly[Manifest[AStruct]]

  lazy val structAnnotations: immutable$Map[String, String] =
    immutable$Map[String, String]()

  override def encode(_item: TestUnion, _oprot: TProtocol) { _item.write(_oprot) }
  override def decode(_iprot: TProtocol): TestUnion = TestUnionDecoder(_iprot, UnknownUnionField(_))

  def apply(_iprot: TProtocol): TestUnion = decode(_iprot)

  import TestUnionAliases._

  def withoutPassthroughFields(struct: TestUnion): TestUnion = {
    struct match {
      case obj: AI32List => withoutPassthroughFields_AI32List(obj)
      case obj: ADoubleSet => withoutPassthroughFields_ADoubleSet(obj)
      case obj: AStruct => withoutPassthroughFields_AStruct(obj)
      case unknown: UnknownUnionField => unknown // by definition pass-through
    }
  }

  object AI32List extends (AI32ListAlias => AI32List) {
    def withoutPassthroughFields(obj: AI32List): AI32List = withoutPassthroughFields_AI32List(obj)

    val fieldInfo =
      new ThriftStructFieldInfo(
        AI32ListField,
        false,
        false,
        manifest[AI32ListAlias],
        AI32ListKeyTypeManifest,
        AI32ListValueTypeManifest,
        immutable$Map(),
        immutable$Map())
  }

  case class AI32List(a_i32_list: AI32ListAlias = AI32ListDefaultValue) extends TestUnion {
    override def write(_oprot: TProtocol) {
      if (a_i32_list == null)
        throw new TProtocolException("Cannot write a TUnion with no set value!")
      _oprot.writeStructBegin(Union)
      if (a_i32_list ne null) {
        val a_i32_list_item = a_i32_list
        _oprot.writeFieldBegin(AI32ListField)
        _oprot.writeListBegin(new TList(TType.I32, a_i32_list_item.size))
        a_i32_list_item.foreach { a_i32_list_item_element =>
          _oprot.writeI32(a_i32_list_item_element)
        }
        _oprot.writeListEnd()
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  object ADoubleSet extends (ADoubleSetAlias => ADoubleSet) {
    def withoutPassthroughFields(obj: ADoubleSet): ADoubleSet = withoutPassthroughFields_ADoubleSet(obj)

    val fieldInfo =
      new ThriftStructFieldInfo(
        ADoubleSetField,
        false,
        false,
        manifest[ADoubleSetAlias],
        ADoubleSetKeyTypeManifest,
        ADoubleSetValueTypeManifest,
        immutable$Map(),
        immutable$Map())
  }

  case class ADoubleSet(a_double_set: ADoubleSetAlias = ADoubleSetDefaultValue) extends TestUnion {
    override def write(_oprot: TProtocol) {
      if (a_double_set == null)
        throw new TProtocolException("Cannot write a TUnion with no set value!")
      _oprot.writeStructBegin(Union)
      if (a_double_set ne null) {
        val a_double_set_item = a_double_set
        _oprot.writeFieldBegin(ADoubleSetField)
        _oprot.writeSetBegin(new TSet(TType.DOUBLE, a_double_set_item.size))
        a_double_set_item.foreach { a_double_set_item_element =>
          _oprot.writeDouble(a_double_set_item_element)
        }
        _oprot.writeSetEnd()
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  object AStruct extends (AStructAlias => AStruct) {
    def withoutPassthroughFields(obj: AStruct): AStruct = withoutPassthroughFields_AStruct(obj)

    val fieldInfo =
      new ThriftStructFieldInfo(
        AStructField,
        false,
        false,
        manifest[AStructAlias],
        AStructKeyTypeManifest,
        AStructValueTypeManifest,
        immutable$Map(),
        immutable$Map())
  }

  case class AStruct(a_struct: AStructAlias) extends TestUnion {
    override def write(_oprot: TProtocol) {
      if (a_struct == null)
        throw new TProtocolException("Cannot write a TUnion with no set value!")
      _oprot.writeStructBegin(Union)
      if (a_struct ne null) {
        val a_struct_item = a_struct
        _oprot.writeFieldBegin(AStructField)
        a_struct_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  case class UnknownUnionField private[TestUnion] (private val field: TFieldBlob) extends TestUnion {
    override def write(_oprot: TProtocol) {
      _oprot.writeStructBegin(Union)
      field.write(_oprot)
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }
}