/**
 * Generated by Scrooge
 *   version: ?
 *   rev: ?
 *   built at: ?
 */
package com.twitter.scalding.commons.macros.scalathrift

import com.twitter.scrooge.{
  TFieldBlob,
  ThriftException,
  ThriftStruct,
  ThriftStructCodec3,
  ThriftStructFieldInfo,
  ThriftUtil
}
import org.apache.thrift.protocol._
import org.apache.thrift.transport.{ TMemoryBuffer, TTransport }
import java.nio.ByteBuffer
import java.util.Arrays
import scala.collection.immutable.{ Map => immutable$Map }
import scala.collection.mutable.Builder
import scala.collection.mutable.{
  ArrayBuffer => mutable$ArrayBuffer,
  Buffer => mutable$Buffer,
  HashMap => mutable$HashMap,
  HashSet => mutable$HashSet
}
import scala.collection.{ Map, Set }

object TestLists extends ThriftStructCodec3[TestLists] {
  private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
  val Struct = new TStruct("TestLists")
  val ABoolListField = new TField("a_bool_list", TType.LIST, 1)
  val ABoolListFieldManifest = implicitly[Manifest[Seq[Boolean]]]
  val AByteListField = new TField("a_byte_list", TType.LIST, 2)
  val AByteListFieldManifest = implicitly[Manifest[Seq[Byte]]]
  val AI16ListField = new TField("a_i16_list", TType.LIST, 3)
  val AI16ListFieldManifest = implicitly[Manifest[Seq[Short]]]
  val AI32ListField = new TField("a_i32_list", TType.LIST, 4)
  val AI32ListFieldManifest = implicitly[Manifest[Seq[Int]]]
  val AI64ListField = new TField("a_i64_list", TType.LIST, 5)
  val AI64ListFieldManifest = implicitly[Manifest[Seq[Long]]]
  val ADoubleListField = new TField("a_double_list", TType.LIST, 6)
  val ADoubleListFieldManifest = implicitly[Manifest[Seq[Double]]]
  val AStringListField = new TField("a_string_list", TType.LIST, 7)
  val AStringListFieldManifest = implicitly[Manifest[Seq[String]]]
  val AStructListField = new TField("a_struct_list", TType.LIST, 8)
  val AStructListFieldManifest = implicitly[Manifest[Seq[TestStruct]]]
  val AListListField = new TField("a_list_list", TType.LIST, 9)
  val AListListFieldManifest = implicitly[Manifest[Seq[Seq[String]]]]
  val ASetListField = new TField("a_set_list", TType.LIST, 10)
  val ASetListFieldManifest = implicitly[Manifest[Seq[Set[String]]]]
  val AMapListField = new TField("a_map_list", TType.LIST, 11)
  val AMapListFieldManifest = implicitly[Manifest[Seq[Map[Int, Int]]]]

  /**
   * Field information in declaration order.
   */
  lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    new ThriftStructFieldInfo(
      ABoolListField,
      false,
      false,
      ABoolListFieldManifest,
      None,
      Some(implicitly[Manifest[Boolean]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AByteListField,
      false,
      false,
      AByteListFieldManifest,
      None,
      Some(implicitly[Manifest[Byte]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AI16ListField,
      false,
      false,
      AI16ListFieldManifest,
      None,
      Some(implicitly[Manifest[Short]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AI32ListField,
      false,
      false,
      AI32ListFieldManifest,
      None,
      Some(implicitly[Manifest[Int]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AI64ListField,
      false,
      false,
      AI64ListFieldManifest,
      None,
      Some(implicitly[Manifest[Long]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      ADoubleListField,
      false,
      false,
      ADoubleListFieldManifest,
      None,
      Some(implicitly[Manifest[Double]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AStringListField,
      false,
      false,
      AStringListFieldManifest,
      None,
      Some(implicitly[Manifest[String]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AStructListField,
      false,
      false,
      AStructListFieldManifest,
      None,
      Some(implicitly[Manifest[TestStruct]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AListListField,
      false,
      false,
      AListListFieldManifest,
      None,
      Some(implicitly[Manifest[Seq[String]]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      ASetListField,
      false,
      false,
      ASetListFieldManifest,
      None,
      Some(implicitly[Manifest[Set[String]]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AMapListField,
      false,
      false,
      AMapListFieldManifest,
      None,
      Some(implicitly[Manifest[Map[Int, Int]]]),
      immutable$Map(),
      immutable$Map()))

  lazy val structAnnotations: immutable$Map[String, String] =
    immutable$Map[String, String]()

  /**
   * Checks that all required fields are non-null.
   */
  def validate(_item: TestLists) {
  }

  def withoutPassthroughFields(original: TestLists): TestLists =
    new Immutable(
      aBoolList =
        {
          val field = original.aBoolList
          field.map { field =>
            field
          }
        },
      aByteList =
        {
          val field = original.aByteList
          field.map { field =>
            field
          }
        },
      aI16List =
        {
          val field = original.aI16List
          field.map { field =>
            field
          }
        },
      aI32List =
        {
          val field = original.aI32List
          field.map { field =>
            field
          }
        },
      aI64List =
        {
          val field = original.aI64List
          field.map { field =>
            field
          }
        },
      aDoubleList =
        {
          val field = original.aDoubleList
          field.map { field =>
            field
          }
        },
      aStringList =
        {
          val field = original.aStringList
          field.map { field =>
            field
          }
        },
      aStructList =
        {
          val field = original.aStructList
          field.map { field =>
            TestStruct.withoutPassthroughFields(field)
          }
        },
      aListList =
        {
          val field = original.aListList
          field.map { field =>
            field.map { field =>
              field
            }
          }
        },
      aSetList =
        {
          val field = original.aSetList
          field.map { field =>
            field.map { field =>
              field
            }
          }
        },
      aMapList =
        {
          val field = original.aMapList
          field.map { field =>
            field.map {
              case (key, value) =>
                val newKey = {
                  val field = key
                  field
                }

                val newValue = {
                  val field = value
                  field
                }

                newKey -> newValue
            }
          }
        })

  override def encode(_item: TestLists, _oproto: TProtocol) {
    _item.write(_oproto)
  }

  override def decode(_iprot: TProtocol): TestLists = {
    var aBoolList: Seq[Boolean] = Seq[Boolean]()
    var aByteList: Seq[Byte] = Seq[Byte]()
    var aI16List: Seq[Short] = Seq[Short]()
    var aI32List: Seq[Int] = Seq[Int]()
    var aI64List: Seq[Long] = Seq[Long]()
    var aDoubleList: Seq[Double] = Seq[Double]()
    var aStringList: Seq[String] = Seq[String]()
    var aStructList: Seq[TestStruct] = Seq[TestStruct]()
    var aListList: Seq[Seq[String]] = Seq[Seq[String]]()
    var aSetList: Seq[Set[String]] = Seq[Set[String]]()
    var aMapList: Seq[Map[Int, Int]] = Seq[Map[Int, Int]]()
    var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
    var _done = false

    _iprot.readStructBegin()
    while (!_done) {
      val _field = _iprot.readFieldBegin()
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 =>
            _field.`type` match {
              case TType.LIST => {
                aBoolList = readABoolListValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.LIST

                throw new TProtocolException(
                  "Received wrong type for field 'aBoolList' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 2 =>
            _field.`type` match {
              case TType.LIST => {
                aByteList = readAByteListValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.LIST

                throw new TProtocolException(
                  "Received wrong type for field 'aByteList' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 3 =>
            _field.`type` match {
              case TType.LIST => {
                aI16List = readAI16ListValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.LIST

                throw new TProtocolException(
                  "Received wrong type for field 'aI16List' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 4 =>
            _field.`type` match {
              case TType.LIST => {
                aI32List = readAI32ListValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.LIST

                throw new TProtocolException(
                  "Received wrong type for field 'aI32List' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 5 =>
            _field.`type` match {
              case TType.LIST => {
                aI64List = readAI64ListValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.LIST

                throw new TProtocolException(
                  "Received wrong type for field 'aI64List' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 6 =>
            _field.`type` match {
              case TType.LIST => {
                aDoubleList = readADoubleListValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.LIST

                throw new TProtocolException(
                  "Received wrong type for field 'aDoubleList' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 7 =>
            _field.`type` match {
              case TType.LIST => {
                aStringList = readAStringListValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.LIST

                throw new TProtocolException(
                  "Received wrong type for field 'aStringList' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 8 =>
            _field.`type` match {
              case TType.LIST => {
                aStructList = readAStructListValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.LIST

                throw new TProtocolException(
                  "Received wrong type for field 'aStructList' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 9 =>
            _field.`type` match {
              case TType.LIST => {
                aListList = readAListListValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.LIST

                throw new TProtocolException(
                  "Received wrong type for field 'aListList' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 10 =>
            _field.`type` match {
              case TType.LIST => {
                aSetList = readASetListValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.LIST

                throw new TProtocolException(
                  "Received wrong type for field 'aSetList' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 11 =>
            _field.`type` match {
              case TType.LIST => {
                aMapList = readAMapListValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.LIST

                throw new TProtocolException(
                  "Received wrong type for field 'aMapList' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case _ =>
            if (_passthroughFields == null)
              _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
            _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()

    new Immutable(
      aBoolList,
      aByteList,
      aI16List,
      aI32List,
      aI64List,
      aDoubleList,
      aStringList,
      aStructList,
      aListList,
      aSetList,
      aMapList,
      if (_passthroughFields == null)
        NoPassthroughFields
      else
        _passthroughFields.result())
  }

  def apply(
    aBoolList: Seq[Boolean] = Seq[Boolean](),
    aByteList: Seq[Byte] = Seq[Byte](),
    aI16List: Seq[Short] = Seq[Short](),
    aI32List: Seq[Int] = Seq[Int](),
    aI64List: Seq[Long] = Seq[Long](),
    aDoubleList: Seq[Double] = Seq[Double](),
    aStringList: Seq[String] = Seq[String](),
    aStructList: Seq[TestStruct] = Seq[TestStruct](),
    aListList: Seq[Seq[String]] = Seq[Seq[String]](),
    aSetList: Seq[Set[String]] = Seq[Set[String]](),
    aMapList: Seq[Map[Int, Int]] = Seq[Map[Int, Int]]()): TestLists =
    new Immutable(
      aBoolList,
      aByteList,
      aI16List,
      aI32List,
      aI64List,
      aDoubleList,
      aStringList,
      aStructList,
      aListList,
      aSetList,
      aMapList)

  def unapply(_item: TestLists): Option[scala.Product11[Seq[Boolean], Seq[Byte], Seq[Short], Seq[Int], Seq[Long], Seq[Double], Seq[String], Seq[TestStruct], Seq[Seq[String]], Seq[Set[String]], Seq[Map[Int, Int]]]] = Some(_item)

  private def readABoolListValue(_iprot: TProtocol): Seq[Boolean] = {
    val _list = _iprot.readListBegin()
    if (_list.size == 0) {
      _iprot.readListEnd()
      Nil
    } else {
      val _rv = new mutable$ArrayBuffer[Boolean](_list.size)
      var _i = 0
      while (_i < _list.size) {
        _rv += {
          _iprot.readBool()

        }
        _i += 1
      }
      _iprot.readListEnd()
      _rv
    }
  }

  private def writeABoolListField(aBoolList_item: Seq[Boolean], _oprot: TProtocol) {
    _oprot.writeFieldBegin(ABoolListField)
    writeABoolListValue(aBoolList_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeABoolListValue(aBoolList_item: Seq[Boolean], _oprot: TProtocol) {
    _oprot.writeListBegin(new TList(TType.BOOL, aBoolList_item.size))
    aBoolList_item.foreach { aBoolList_item_element =>
      _oprot.writeBool(aBoolList_item_element)
    }
    _oprot.writeListEnd()
  }

  private def readAByteListValue(_iprot: TProtocol): Seq[Byte] = {
    val _list = _iprot.readListBegin()
    if (_list.size == 0) {
      _iprot.readListEnd()
      Nil
    } else {
      val _rv = new mutable$ArrayBuffer[Byte](_list.size)
      var _i = 0
      while (_i < _list.size) {
        _rv += {
          _iprot.readByte()

        }
        _i += 1
      }
      _iprot.readListEnd()
      _rv
    }
  }

  private def writeAByteListField(aByteList_item: Seq[Byte], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AByteListField)
    writeAByteListValue(aByteList_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAByteListValue(aByteList_item: Seq[Byte], _oprot: TProtocol) {
    _oprot.writeListBegin(new TList(TType.BYTE, aByteList_item.size))
    aByteList_item.foreach { aByteList_item_element =>
      _oprot.writeByte(aByteList_item_element)
    }
    _oprot.writeListEnd()
  }

  private def readAI16ListValue(_iprot: TProtocol): Seq[Short] = {
    val _list = _iprot.readListBegin()
    if (_list.size == 0) {
      _iprot.readListEnd()
      Nil
    } else {
      val _rv = new mutable$ArrayBuffer[Short](_list.size)
      var _i = 0
      while (_i < _list.size) {
        _rv += {
          _iprot.readI16()

        }
        _i += 1
      }
      _iprot.readListEnd()
      _rv
    }
  }

  private def writeAI16ListField(aI16List_item: Seq[Short], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AI16ListField)
    writeAI16ListValue(aI16List_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAI16ListValue(aI16List_item: Seq[Short], _oprot: TProtocol) {
    _oprot.writeListBegin(new TList(TType.I16, aI16List_item.size))
    aI16List_item.foreach { aI16List_item_element =>
      _oprot.writeI16(aI16List_item_element)
    }
    _oprot.writeListEnd()
  }

  private def readAI32ListValue(_iprot: TProtocol): Seq[Int] = {
    val _list = _iprot.readListBegin()
    if (_list.size == 0) {
      _iprot.readListEnd()
      Nil
    } else {
      val _rv = new mutable$ArrayBuffer[Int](_list.size)
      var _i = 0
      while (_i < _list.size) {
        _rv += {
          _iprot.readI32()

        }
        _i += 1
      }
      _iprot.readListEnd()
      _rv
    }
  }

  private def writeAI32ListField(aI32List_item: Seq[Int], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AI32ListField)
    writeAI32ListValue(aI32List_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAI32ListValue(aI32List_item: Seq[Int], _oprot: TProtocol) {
    _oprot.writeListBegin(new TList(TType.I32, aI32List_item.size))
    aI32List_item.foreach { aI32List_item_element =>
      _oprot.writeI32(aI32List_item_element)
    }
    _oprot.writeListEnd()
  }

  private def readAI64ListValue(_iprot: TProtocol): Seq[Long] = {
    val _list = _iprot.readListBegin()
    if (_list.size == 0) {
      _iprot.readListEnd()
      Nil
    } else {
      val _rv = new mutable$ArrayBuffer[Long](_list.size)
      var _i = 0
      while (_i < _list.size) {
        _rv += {
          _iprot.readI64()

        }
        _i += 1
      }
      _iprot.readListEnd()
      _rv
    }
  }

  private def writeAI64ListField(aI64List_item: Seq[Long], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AI64ListField)
    writeAI64ListValue(aI64List_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAI64ListValue(aI64List_item: Seq[Long], _oprot: TProtocol) {
    _oprot.writeListBegin(new TList(TType.I64, aI64List_item.size))
    aI64List_item.foreach { aI64List_item_element =>
      _oprot.writeI64(aI64List_item_element)
    }
    _oprot.writeListEnd()
  }

  private def readADoubleListValue(_iprot: TProtocol): Seq[Double] = {
    val _list = _iprot.readListBegin()
    if (_list.size == 0) {
      _iprot.readListEnd()
      Nil
    } else {
      val _rv = new mutable$ArrayBuffer[Double](_list.size)
      var _i = 0
      while (_i < _list.size) {
        _rv += {
          _iprot.readDouble()

        }
        _i += 1
      }
      _iprot.readListEnd()
      _rv
    }
  }

  private def writeADoubleListField(aDoubleList_item: Seq[Double], _oprot: TProtocol) {
    _oprot.writeFieldBegin(ADoubleListField)
    writeADoubleListValue(aDoubleList_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeADoubleListValue(aDoubleList_item: Seq[Double], _oprot: TProtocol) {
    _oprot.writeListBegin(new TList(TType.DOUBLE, aDoubleList_item.size))
    aDoubleList_item.foreach { aDoubleList_item_element =>
      _oprot.writeDouble(aDoubleList_item_element)
    }
    _oprot.writeListEnd()
  }

  private def readAStringListValue(_iprot: TProtocol): Seq[String] = {
    val _list = _iprot.readListBegin()
    if (_list.size == 0) {
      _iprot.readListEnd()
      Nil
    } else {
      val _rv = new mutable$ArrayBuffer[String](_list.size)
      var _i = 0
      while (_i < _list.size) {
        _rv += {
          _iprot.readString()

        }
        _i += 1
      }
      _iprot.readListEnd()
      _rv
    }
  }

  private def writeAStringListField(aStringList_item: Seq[String], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AStringListField)
    writeAStringListValue(aStringList_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAStringListValue(aStringList_item: Seq[String], _oprot: TProtocol) {
    _oprot.writeListBegin(new TList(TType.STRING, aStringList_item.size))
    aStringList_item.foreach { aStringList_item_element =>
      _oprot.writeString(aStringList_item_element)
    }
    _oprot.writeListEnd()
  }

  private def readAStructListValue(_iprot: TProtocol): Seq[TestStruct] = {
    val _list = _iprot.readListBegin()
    if (_list.size == 0) {
      _iprot.readListEnd()
      Nil
    } else {
      val _rv = new mutable$ArrayBuffer[TestStruct](_list.size)
      var _i = 0
      while (_i < _list.size) {
        _rv += {
          TestStruct.decode(_iprot)

        }
        _i += 1
      }
      _iprot.readListEnd()
      _rv
    }
  }

  private def writeAStructListField(aStructList_item: Seq[TestStruct], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AStructListField)
    writeAStructListValue(aStructList_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAStructListValue(aStructList_item: Seq[TestStruct], _oprot: TProtocol) {
    _oprot.writeListBegin(new TList(TType.STRUCT, aStructList_item.size))
    aStructList_item.foreach { aStructList_item_element =>
      aStructList_item_element.write(_oprot)
    }
    _oprot.writeListEnd()
  }

  private def readAListListValue(_iprot: TProtocol): Seq[Seq[String]] = {
    val _list = _iprot.readListBegin()
    if (_list.size == 0) {
      _iprot.readListEnd()
      Nil
    } else {
      val _rv = new mutable$ArrayBuffer[Seq[String]](_list.size)
      var _i = 0
      while (_i < _list.size) {
        _rv += {
          val _list = _iprot.readListBegin()
          if (_list.size == 0) {
            _iprot.readListEnd()
            Nil
          } else {
            val _rv = new mutable$ArrayBuffer[String](_list.size)
            var _i = 0
            while (_i < _list.size) {
              _rv += {
                _iprot.readString()

              }
              _i += 1
            }
            _iprot.readListEnd()
            _rv
          }

        }
        _i += 1
      }
      _iprot.readListEnd()
      _rv
    }
  }

  private def writeAListListField(aListList_item: Seq[Seq[String]], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AListListField)
    writeAListListValue(aListList_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAListListValue(aListList_item: Seq[Seq[String]], _oprot: TProtocol) {
    _oprot.writeListBegin(new TList(TType.LIST, aListList_item.size))
    aListList_item.foreach { aListList_item_element =>
      _oprot.writeListBegin(new TList(TType.STRING, aListList_item_element.size))
      aListList_item_element.foreach { aListList_item_element_element =>
        _oprot.writeString(aListList_item_element_element)
      }
      _oprot.writeListEnd()
    }
    _oprot.writeListEnd()
  }

  private def readASetListValue(_iprot: TProtocol): Seq[Set[String]] = {
    val _list = _iprot.readListBegin()
    if (_list.size == 0) {
      _iprot.readListEnd()
      Nil
    } else {
      val _rv = new mutable$ArrayBuffer[Set[String]](_list.size)
      var _i = 0
      while (_i < _list.size) {
        _rv += {
          val _set = _iprot.readSetBegin()
          if (_set.size == 0) {
            _iprot.readSetEnd()
            Set.empty[String]
          } else {
            val _rv = new mutable$HashSet[String]
            var _i = 0
            while (_i < _set.size) {
              _rv += {
                _iprot.readString()

              }
              _i += 1
            }
            _iprot.readSetEnd()
            _rv
          }

        }
        _i += 1
      }
      _iprot.readListEnd()
      _rv
    }
  }

  private def writeASetListField(aSetList_item: Seq[Set[String]], _oprot: TProtocol) {
    _oprot.writeFieldBegin(ASetListField)
    writeASetListValue(aSetList_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeASetListValue(aSetList_item: Seq[Set[String]], _oprot: TProtocol) {
    _oprot.writeListBegin(new TList(TType.SET, aSetList_item.size))
    aSetList_item.foreach { aSetList_item_element =>
      _oprot.writeSetBegin(new TSet(TType.STRING, aSetList_item_element.size))
      aSetList_item_element.foreach { aSetList_item_element_element =>
        _oprot.writeString(aSetList_item_element_element)
      }
      _oprot.writeSetEnd()
    }
    _oprot.writeListEnd()
  }

  private def readAMapListValue(_iprot: TProtocol): Seq[Map[Int, Int]] = {
    val _list = _iprot.readListBegin()
    if (_list.size == 0) {
      _iprot.readListEnd()
      Nil
    } else {
      val _rv = new mutable$ArrayBuffer[Map[Int, Int]](_list.size)
      var _i = 0
      while (_i < _list.size) {
        _rv += {
          val _map = _iprot.readMapBegin()
          if (_map.size == 0) {
            _iprot.readMapEnd()
            Map.empty[Int, Int]
          } else {
            val _rv = new mutable$HashMap[Int, Int]
            var _i = 0
            while (_i < _map.size) {
              val _key = {
                _iprot.readI32()

              }
              val _value = {
                _iprot.readI32()

              }
              _rv(_key) = _value
              _i += 1
            }
            _iprot.readMapEnd()
            _rv
          }

        }
        _i += 1
      }
      _iprot.readListEnd()
      _rv
    }
  }

  private def writeAMapListField(aMapList_item: Seq[Map[Int, Int]], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AMapListField)
    writeAMapListValue(aMapList_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAMapListValue(aMapList_item: Seq[Map[Int, Int]], _oprot: TProtocol) {
    _oprot.writeListBegin(new TList(TType.MAP, aMapList_item.size))
    aMapList_item.foreach { aMapList_item_element =>
      _oprot.writeMapBegin(new TMap(TType.I32, TType.I32, aMapList_item_element.size))
      aMapList_item_element.foreach { _pair =>
        val aMapList_item_element_key = _pair._1
        val aMapList_item_element_value = _pair._2
        _oprot.writeI32(aMapList_item_element_key)
        _oprot.writeI32(aMapList_item_element_value)
      }
      _oprot.writeMapEnd()
    }
    _oprot.writeListEnd()
  }

  private def ttypeToHuman(byte: Byte) = {
    // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
    byte match {
      case TType.STOP => "STOP"
      case TType.VOID => "VOID"
      case TType.BOOL => "BOOL"
      case TType.BYTE => "BYTE"
      case TType.DOUBLE => "DOUBLE"
      case TType.I16 => "I16"
      case TType.I32 => "I32"
      case TType.I64 => "I64"
      case TType.STRING => "STRING"
      case TType.STRUCT => "STRUCT"
      case TType.MAP => "MAP"
      case TType.SET => "SET"
      case TType.LIST => "LIST"
      case TType.ENUM => "ENUM"
      case _ => "UNKNOWN"
    }
  }

  object Immutable extends ThriftStructCodec3[TestLists] {
    override def encode(_item: TestLists, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): TestLists = TestLists.decode(_iprot)
  }

  /**
   * The default read-only implementation of TestLists.  You typically should not need to
   * directly reference this class; instead, use the TestLists.apply method to construct
   * new instances.
   */
  class Immutable(
    val aBoolList: Seq[Boolean],
    val aByteList: Seq[Byte],
    val aI16List: Seq[Short],
    val aI32List: Seq[Int],
    val aI64List: Seq[Long],
    val aDoubleList: Seq[Double],
    val aStringList: Seq[String],
    val aStructList: Seq[TestStruct],
    val aListList: Seq[Seq[String]],
    val aSetList: Seq[Set[String]],
    val aMapList: Seq[Map[Int, Int]],
    override val _passthroughFields: immutable$Map[Short, TFieldBlob]) extends TestLists {
    def this(
      aBoolList: Seq[Boolean] = Seq[Boolean](),
      aByteList: Seq[Byte] = Seq[Byte](),
      aI16List: Seq[Short] = Seq[Short](),
      aI32List: Seq[Int] = Seq[Int](),
      aI64List: Seq[Long] = Seq[Long](),
      aDoubleList: Seq[Double] = Seq[Double](),
      aStringList: Seq[String] = Seq[String](),
      aStructList: Seq[TestStruct] = Seq[TestStruct](),
      aListList: Seq[Seq[String]] = Seq[Seq[String]](),
      aSetList: Seq[Set[String]] = Seq[Set[String]](),
      aMapList: Seq[Map[Int, Int]] = Seq[Map[Int, Int]]()) = this(
      aBoolList,
      aByteList,
      aI16List,
      aI32List,
      aI64List,
      aDoubleList,
      aStringList,
      aStructList,
      aListList,
      aSetList,
      aMapList,
      Map.empty)
  }

  /**
   * This Proxy trait allows you to extend the TestLists trait with additional state or
   * behavior and implement the read-only methods from TestLists using an underlying
   * instance.
   */
  trait Proxy extends TestLists {
    protected def _underlying_TestLists: TestLists
    override def aBoolList: Seq[Boolean] = _underlying_TestLists.aBoolList
    override def aByteList: Seq[Byte] = _underlying_TestLists.aByteList
    override def aI16List: Seq[Short] = _underlying_TestLists.aI16List
    override def aI32List: Seq[Int] = _underlying_TestLists.aI32List
    override def aI64List: Seq[Long] = _underlying_TestLists.aI64List
    override def aDoubleList: Seq[Double] = _underlying_TestLists.aDoubleList
    override def aStringList: Seq[String] = _underlying_TestLists.aStringList
    override def aStructList: Seq[TestStruct] = _underlying_TestLists.aStructList
    override def aListList: Seq[Seq[String]] = _underlying_TestLists.aListList
    override def aSetList: Seq[Set[String]] = _underlying_TestLists.aSetList
    override def aMapList: Seq[Map[Int, Int]] = _underlying_TestLists.aMapList
    override def _passthroughFields = _underlying_TestLists._passthroughFields
  }
}

trait TestLists
  extends ThriftStruct
  with scala.Product11[Seq[Boolean], Seq[Byte], Seq[Short], Seq[Int], Seq[Long], Seq[Double], Seq[String], Seq[TestStruct], Seq[Seq[String]], Seq[Set[String]], Seq[Map[Int, Int]]]
  with java.io.Serializable {
  import TestLists._

  def aBoolList: Seq[Boolean]
  def aByteList: Seq[Byte]
  def aI16List: Seq[Short]
  def aI32List: Seq[Int]
  def aI64List: Seq[Long]
  def aDoubleList: Seq[Double]
  def aStringList: Seq[String]
  def aStructList: Seq[TestStruct]
  def aListList: Seq[Seq[String]]
  def aSetList: Seq[Set[String]]
  def aMapList: Seq[Map[Int, Int]]

  def _passthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty

  def _1 = aBoolList
  def _2 = aByteList
  def _3 = aI16List
  def _4 = aI32List
  def _5 = aI64List
  def _6 = aDoubleList
  def _7 = aStringList
  def _8 = aStructList
  def _9 = aListList
  def _10 = aSetList
  def _11 = aMapList

  /**
   * Gets a field value encoded as a binary blob using TCompactProtocol.  If the specified field
   * is present in the passthrough map, that value is returend.  Otherwise, if the specified field
   * is known and not optional and set to None, then the field is serialized and returned.
   */
  def getFieldBlob(_fieldId: Short): Option[TFieldBlob] = {
    lazy val _buff = new TMemoryBuffer(32)
    lazy val _oprot = new TCompactProtocol(_buff)
    _passthroughFields.get(_fieldId) orElse {
      val _fieldOpt: Option[TField] =
        _fieldId match {
          case 1 =>
            if (aBoolList ne null) {
              writeABoolListValue(aBoolList, _oprot)
              Some(TestLists.ABoolListField)
            } else {
              None
            }
          case 2 =>
            if (aByteList ne null) {
              writeAByteListValue(aByteList, _oprot)
              Some(TestLists.AByteListField)
            } else {
              None
            }
          case 3 =>
            if (aI16List ne null) {
              writeAI16ListValue(aI16List, _oprot)
              Some(TestLists.AI16ListField)
            } else {
              None
            }
          case 4 =>
            if (aI32List ne null) {
              writeAI32ListValue(aI32List, _oprot)
              Some(TestLists.AI32ListField)
            } else {
              None
            }
          case 5 =>
            if (aI64List ne null) {
              writeAI64ListValue(aI64List, _oprot)
              Some(TestLists.AI64ListField)
            } else {
              None
            }
          case 6 =>
            if (aDoubleList ne null) {
              writeADoubleListValue(aDoubleList, _oprot)
              Some(TestLists.ADoubleListField)
            } else {
              None
            }
          case 7 =>
            if (aStringList ne null) {
              writeAStringListValue(aStringList, _oprot)
              Some(TestLists.AStringListField)
            } else {
              None
            }
          case 8 =>
            if (aStructList ne null) {
              writeAStructListValue(aStructList, _oprot)
              Some(TestLists.AStructListField)
            } else {
              None
            }
          case 9 =>
            if (aListList ne null) {
              writeAListListValue(aListList, _oprot)
              Some(TestLists.AListListField)
            } else {
              None
            }
          case 10 =>
            if (aSetList ne null) {
              writeASetListValue(aSetList, _oprot)
              Some(TestLists.ASetListField)
            } else {
              None
            }
          case 11 =>
            if (aMapList ne null) {
              writeAMapListValue(aMapList, _oprot)
              Some(TestLists.AMapListField)
            } else {
              None
            }
          case _ => None
        }
      _fieldOpt match {
        case Some(_field) =>
          val _data = Arrays.copyOfRange(_buff.getArray, 0, _buff.length)
          Some(TFieldBlob(_field, _data))
        case None =>
          None
      }
    }
  }

  /**
   * Collects TCompactProtocol-encoded field values according to `getFieldBlob` into a map.
   */
  def getFieldBlobs(ids: TraversableOnce[Short]): immutable$Map[Short, TFieldBlob] =
    (ids flatMap { id => getFieldBlob(id) map { id -> _ } }).toMap

  /**
   * Sets a field using a TCompactProtocol-encoded binary blob.  If the field is a known
   * field, the blob is decoded and the field is set to the decoded value.  If the field
   * is unknown and passthrough fields are enabled, then the blob will be stored in
   * _passthroughFields.
   */
  def setField(_blob: TFieldBlob): TestLists = {
    var aBoolList: Seq[Boolean] = this.aBoolList
    var aByteList: Seq[Byte] = this.aByteList
    var aI16List: Seq[Short] = this.aI16List
    var aI32List: Seq[Int] = this.aI32List
    var aI64List: Seq[Long] = this.aI64List
    var aDoubleList: Seq[Double] = this.aDoubleList
    var aStringList: Seq[String] = this.aStringList
    var aStructList: Seq[TestStruct] = this.aStructList
    var aListList: Seq[Seq[String]] = this.aListList
    var aSetList: Seq[Set[String]] = this.aSetList
    var aMapList: Seq[Map[Int, Int]] = this.aMapList
    var _passthroughFields = this._passthroughFields
    _blob.id match {
      case 1 =>
        aBoolList = readABoolListValue(_blob.read)
      case 2 =>
        aByteList = readAByteListValue(_blob.read)
      case 3 =>
        aI16List = readAI16ListValue(_blob.read)
      case 4 =>
        aI32List = readAI32ListValue(_blob.read)
      case 5 =>
        aI64List = readAI64ListValue(_blob.read)
      case 6 =>
        aDoubleList = readADoubleListValue(_blob.read)
      case 7 =>
        aStringList = readAStringListValue(_blob.read)
      case 8 =>
        aStructList = readAStructListValue(_blob.read)
      case 9 =>
        aListList = readAListListValue(_blob.read)
      case 10 =>
        aSetList = readASetListValue(_blob.read)
      case 11 =>
        aMapList = readAMapListValue(_blob.read)
      case _ => _passthroughFields += (_blob.id -> _blob)
    }
    new Immutable(
      aBoolList,
      aByteList,
      aI16List,
      aI32List,
      aI64List,
      aDoubleList,
      aStringList,
      aStructList,
      aListList,
      aSetList,
      aMapList,
      _passthroughFields)
  }

  /**
   * If the specified field is optional, it is set to None.  Otherwise, if the field is
   * known, it is reverted to its default value; if the field is unknown, it is subtracked
   * from the passthroughFields map, if present.
   */
  def unsetField(_fieldId: Short): TestLists = {
    var aBoolList: Seq[Boolean] = this.aBoolList
    var aByteList: Seq[Byte] = this.aByteList
    var aI16List: Seq[Short] = this.aI16List
    var aI32List: Seq[Int] = this.aI32List
    var aI64List: Seq[Long] = this.aI64List
    var aDoubleList: Seq[Double] = this.aDoubleList
    var aStringList: Seq[String] = this.aStringList
    var aStructList: Seq[TestStruct] = this.aStructList
    var aListList: Seq[Seq[String]] = this.aListList
    var aSetList: Seq[Set[String]] = this.aSetList
    var aMapList: Seq[Map[Int, Int]] = this.aMapList

    _fieldId match {
      case 1 =>
        aBoolList = Seq[Boolean]()
      case 2 =>
        aByteList = Seq[Byte]()
      case 3 =>
        aI16List = Seq[Short]()
      case 4 =>
        aI32List = Seq[Int]()
      case 5 =>
        aI64List = Seq[Long]()
      case 6 =>
        aDoubleList = Seq[Double]()
      case 7 =>
        aStringList = Seq[String]()
      case 8 =>
        aStructList = Seq[TestStruct]()
      case 9 =>
        aListList = Seq[Seq[String]]()
      case 10 =>
        aSetList = Seq[Set[String]]()
      case 11 =>
        aMapList = Seq[Map[Int, Int]]()
      case _ =>
    }
    new Immutable(
      aBoolList,
      aByteList,
      aI16List,
      aI32List,
      aI64List,
      aDoubleList,
      aStringList,
      aStructList,
      aListList,
      aSetList,
      aMapList,
      _passthroughFields - _fieldId)
  }

  /**
   * If the specified field is optional, it is set to None.  Otherwise, if the field is
   * known, it is reverted to its default value; if the field is unknown, it is subtracked
   * from the passthroughFields map, if present.
   */
  def unsetABoolList: TestLists = unsetField(1)

  def unsetAByteList: TestLists = unsetField(2)

  def unsetAI16List: TestLists = unsetField(3)

  def unsetAI32List: TestLists = unsetField(4)

  def unsetAI64List: TestLists = unsetField(5)

  def unsetADoubleList: TestLists = unsetField(6)

  def unsetAStringList: TestLists = unsetField(7)

  def unsetAStructList: TestLists = unsetField(8)

  def unsetAListList: TestLists = unsetField(9)

  def unsetASetList: TestLists = unsetField(10)

  def unsetAMapList: TestLists = unsetField(11)

  override def write(_oprot: TProtocol) {
    TestLists.validate(this)
    _oprot.writeStructBegin(Struct)
    if (aBoolList ne null) writeABoolListField(aBoolList, _oprot)
    if (aByteList ne null) writeAByteListField(aByteList, _oprot)
    if (aI16List ne null) writeAI16ListField(aI16List, _oprot)
    if (aI32List ne null) writeAI32ListField(aI32List, _oprot)
    if (aI64List ne null) writeAI64ListField(aI64List, _oprot)
    if (aDoubleList ne null) writeADoubleListField(aDoubleList, _oprot)
    if (aStringList ne null) writeAStringListField(aStringList, _oprot)
    if (aStructList ne null) writeAStructListField(aStructList, _oprot)
    if (aListList ne null) writeAListListField(aListList, _oprot)
    if (aSetList ne null) writeASetListField(aSetList, _oprot)
    if (aMapList ne null) writeAMapListField(aMapList, _oprot)
    _passthroughFields.values foreach { _.write(_oprot) }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def copy(
    aBoolList: Seq[Boolean] = this.aBoolList,
    aByteList: Seq[Byte] = this.aByteList,
    aI16List: Seq[Short] = this.aI16List,
    aI32List: Seq[Int] = this.aI32List,
    aI64List: Seq[Long] = this.aI64List,
    aDoubleList: Seq[Double] = this.aDoubleList,
    aStringList: Seq[String] = this.aStringList,
    aStructList: Seq[TestStruct] = this.aStructList,
    aListList: Seq[Seq[String]] = this.aListList,
    aSetList: Seq[Set[String]] = this.aSetList,
    aMapList: Seq[Map[Int, Int]] = this.aMapList,
    _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields): TestLists =
    new Immutable(
      aBoolList,
      aByteList,
      aI16List,
      aI32List,
      aI64List,
      aDoubleList,
      aStringList,
      aStructList,
      aListList,
      aSetList,
      aMapList,
      _passthroughFields)

  override def canEqual(other: Any): Boolean = other.isInstanceOf[TestLists]

  override def equals(other: Any): Boolean =
    _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
      _passthroughFields == other.asInstanceOf[TestLists]._passthroughFields

  override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)

  override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)

  override def productArity: Int = 11

  override def productElement(n: Int): Any = n match {
    case 0 => this.aBoolList
    case 1 => this.aByteList
    case 2 => this.aI16List
    case 3 => this.aI32List
    case 4 => this.aI64List
    case 5 => this.aDoubleList
    case 6 => this.aStringList
    case 7 => this.aStructList
    case 8 => this.aListList
    case 9 => this.aSetList
    case 10 => this.aMapList
    case _ => throw new IndexOutOfBoundsException(n.toString)
  }

  override def productPrefix: String = "TestLists"
}