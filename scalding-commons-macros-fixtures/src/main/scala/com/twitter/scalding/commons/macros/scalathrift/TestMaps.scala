/**
 * Generated by Scrooge
 *   version: ?
 *   rev: ?
 *   built at: ?
 */
package com.twitter.scalding.commons.macros.scalathrift

import com.twitter.scrooge.{
  TFieldBlob,
  ThriftException,
  ThriftStruct,
  ThriftStructCodec3,
  ThriftStructFieldInfo,
  ThriftUtil
}
import org.apache.thrift.protocol._
import org.apache.thrift.transport.{ TMemoryBuffer, TTransport }
import java.nio.ByteBuffer
import java.util.Arrays
import scala.collection.immutable.{ Map => immutable$Map }
import scala.collection.mutable.Builder
import scala.collection.mutable.{
  ArrayBuffer => mutable$ArrayBuffer,
  Buffer => mutable$Buffer,
  HashMap => mutable$HashMap,
  HashSet => mutable$HashSet
}
import scala.collection.{ Map, Set }

object TestMaps extends ThriftStructCodec3[TestMaps] {
  private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
  val Struct = new TStruct("TestMaps")
  val ABoolMapField = new TField("a_bool_map", TType.MAP, 1)
  val ABoolMapFieldManifest = implicitly[Manifest[Map[Boolean, String]]]
  val AByteMapField = new TField("a_byte_map", TType.MAP, 2)
  val AByteMapFieldManifest = implicitly[Manifest[Map[Byte, Double]]]
  val AI16MapField = new TField("a_i16_map", TType.MAP, 3)
  val AI16MapFieldManifest = implicitly[Manifest[Map[Short, Long]]]
  val AI32MapField = new TField("a_i32_map", TType.MAP, 4)
  val AI32MapFieldManifest = implicitly[Manifest[Map[Int, Int]]]
  val AI64MapField = new TField("a_i64_map", TType.MAP, 5)
  val AI64MapFieldManifest = implicitly[Manifest[Map[Long, Short]]]
  val ADoubleMapField = new TField("a_double_map", TType.MAP, 6)
  val ADoubleMapFieldManifest = implicitly[Manifest[Map[Double, Byte]]]
  val AStringMapField = new TField("a_string_map", TType.MAP, 7)
  val AStringMapFieldManifest = implicitly[Manifest[Map[String, Boolean]]]
  val AStructMapField = new TField("a_struct_map", TType.MAP, 8)
  val AStructMapFieldManifest = implicitly[Manifest[Map[TestStruct, Seq[String]]]]
  val AListMapField = new TField("a_list_map", TType.MAP, 9)
  val AListMapFieldManifest = implicitly[Manifest[Map[Seq[String], TestStruct]]]
  val ASetMapField = new TField("a_set_map", TType.MAP, 10)
  val ASetMapFieldManifest = implicitly[Manifest[Map[Set[String], Set[String]]]]
  val AMapMapField = new TField("a_map_map", TType.MAP, 11)
  val AMapMapFieldManifest = implicitly[Manifest[Map[Map[Int, Int], Map[Int, Int]]]]

  /**
   * Field information in declaration order.
   */
  lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
    new ThriftStructFieldInfo(
      ABoolMapField,
      false,
      false,
      ABoolMapFieldManifest,
      Some(implicitly[Manifest[Boolean]]),
      Some(implicitly[Manifest[String]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AByteMapField,
      false,
      false,
      AByteMapFieldManifest,
      Some(implicitly[Manifest[Byte]]),
      Some(implicitly[Manifest[Double]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AI16MapField,
      false,
      false,
      AI16MapFieldManifest,
      Some(implicitly[Manifest[Short]]),
      Some(implicitly[Manifest[Long]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AI32MapField,
      false,
      false,
      AI32MapFieldManifest,
      Some(implicitly[Manifest[Int]]),
      Some(implicitly[Manifest[Int]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AI64MapField,
      false,
      false,
      AI64MapFieldManifest,
      Some(implicitly[Manifest[Long]]),
      Some(implicitly[Manifest[Short]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      ADoubleMapField,
      false,
      false,
      ADoubleMapFieldManifest,
      Some(implicitly[Manifest[Double]]),
      Some(implicitly[Manifest[Byte]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AStringMapField,
      false,
      false,
      AStringMapFieldManifest,
      Some(implicitly[Manifest[String]]),
      Some(implicitly[Manifest[Boolean]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AStructMapField,
      false,
      false,
      AStructMapFieldManifest,
      Some(implicitly[Manifest[TestStruct]]),
      Some(implicitly[Manifest[Seq[String]]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AListMapField,
      false,
      false,
      AListMapFieldManifest,
      Some(implicitly[Manifest[Seq[String]]]),
      Some(implicitly[Manifest[TestStruct]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      ASetMapField,
      false,
      false,
      ASetMapFieldManifest,
      Some(implicitly[Manifest[Set[String]]]),
      Some(implicitly[Manifest[Set[String]]]),
      immutable$Map(),
      immutable$Map()),
    new ThriftStructFieldInfo(
      AMapMapField,
      false,
      false,
      AMapMapFieldManifest,
      Some(implicitly[Manifest[Map[Int, Int]]]),
      Some(implicitly[Manifest[Map[Int, Int]]]),
      immutable$Map(),
      immutable$Map()))

  lazy val structAnnotations: immutable$Map[String, String] =
    immutable$Map[String, String]()

  /**
   * Checks that all required fields are non-null.
   */
  def validate(_item: TestMaps) {
  }

  def withoutPassthroughFields(original: TestMaps): TestMaps =
    new Immutable(
      aBoolMap =
        {
          val field = original.aBoolMap
          field.map {
            case (key, value) =>
              val newKey = {
                val field = key
                field
              }

              val newValue = {
                val field = value
                field
              }

              newKey -> newValue
          }
        },
      aByteMap =
        {
          val field = original.aByteMap
          field.map {
            case (key, value) =>
              val newKey = {
                val field = key
                field
              }

              val newValue = {
                val field = value
                field
              }

              newKey -> newValue
          }
        },
      aI16Map =
        {
          val field = original.aI16Map
          field.map {
            case (key, value) =>
              val newKey = {
                val field = key
                field
              }

              val newValue = {
                val field = value
                field
              }

              newKey -> newValue
          }
        },
      aI32Map =
        {
          val field = original.aI32Map
          field.map {
            case (key, value) =>
              val newKey = {
                val field = key
                field
              }

              val newValue = {
                val field = value
                field
              }

              newKey -> newValue
          }
        },
      aI64Map =
        {
          val field = original.aI64Map
          field.map {
            case (key, value) =>
              val newKey = {
                val field = key
                field
              }

              val newValue = {
                val field = value
                field
              }

              newKey -> newValue
          }
        },
      aDoubleMap =
        {
          val field = original.aDoubleMap
          field.map {
            case (key, value) =>
              val newKey = {
                val field = key
                field
              }

              val newValue = {
                val field = value
                field
              }

              newKey -> newValue
          }
        },
      aStringMap =
        {
          val field = original.aStringMap
          field.map {
            case (key, value) =>
              val newKey = {
                val field = key
                field
              }

              val newValue = {
                val field = value
                field
              }

              newKey -> newValue
          }
        },
      aStructMap =
        {
          val field = original.aStructMap
          field.map {
            case (key, value) =>
              val newKey = {
                val field = key
                TestStruct.withoutPassthroughFields(field)
              }

              val newValue = {
                val field = value
                field.map { field =>
                  field
                }
              }

              newKey -> newValue
          }
        },
      aListMap =
        {
          val field = original.aListMap
          field.map {
            case (key, value) =>
              val newKey = {
                val field = key
                field.map { field =>
                  field
                }
              }

              val newValue = {
                val field = value
                TestStruct.withoutPassthroughFields(field)
              }

              newKey -> newValue
          }
        },
      aSetMap =
        {
          val field = original.aSetMap
          field.map {
            case (key, value) =>
              val newKey = {
                val field = key
                field.map { field =>
                  field
                }
              }

              val newValue = {
                val field = value
                field.map { field =>
                  field
                }
              }

              newKey -> newValue
          }
        },
      aMapMap =
        {
          val field = original.aMapMap
          field.map {
            case (key, value) =>
              val newKey = {
                val field = key
                field.map {
                  case (key, value) =>
                    val newKey = {
                      val field = key
                      field
                    }

                    val newValue = {
                      val field = value
                      field
                    }

                    newKey -> newValue
                }
              }

              val newValue = {
                val field = value
                field.map {
                  case (key, value) =>
                    val newKey = {
                      val field = key
                      field
                    }

                    val newValue = {
                      val field = value
                      field
                    }

                    newKey -> newValue
                }
              }

              newKey -> newValue
          }
        })

  override def encode(_item: TestMaps, _oproto: TProtocol) {
    _item.write(_oproto)
  }

  override def decode(_iprot: TProtocol): TestMaps = {
    var aBoolMap: Map[Boolean, String] = Map[Boolean, String]()
    var aByteMap: Map[Byte, Double] = Map[Byte, Double]()
    var aI16Map: Map[Short, Long] = Map[Short, Long]()
    var aI32Map: Map[Int, Int] = Map[Int, Int]()
    var aI64Map: Map[Long, Short] = Map[Long, Short]()
    var aDoubleMap: Map[Double, Byte] = Map[Double, Byte]()
    var aStringMap: Map[String, Boolean] = Map[String, Boolean]()
    var aStructMap: Map[TestStruct, Seq[String]] = Map[TestStruct, Seq[String]]()
    var aListMap: Map[Seq[String], TestStruct] = Map[Seq[String], TestStruct]()
    var aSetMap: Map[Set[String], Set[String]] = Map[Set[String], Set[String]]()
    var aMapMap: Map[Map[Int, Int], Map[Int, Int]] = Map[Map[Int, Int], Map[Int, Int]]()
    var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
    var _done = false

    _iprot.readStructBegin()
    while (!_done) {
      val _field = _iprot.readFieldBegin()
      if (_field.`type` == TType.STOP) {
        _done = true
      } else {
        _field.id match {
          case 1 =>
            _field.`type` match {
              case TType.MAP => {
                aBoolMap = readABoolMapValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.MAP

                throw new TProtocolException(
                  "Received wrong type for field 'aBoolMap' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 2 =>
            _field.`type` match {
              case TType.MAP => {
                aByteMap = readAByteMapValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.MAP

                throw new TProtocolException(
                  "Received wrong type for field 'aByteMap' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 3 =>
            _field.`type` match {
              case TType.MAP => {
                aI16Map = readAI16MapValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.MAP

                throw new TProtocolException(
                  "Received wrong type for field 'aI16Map' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 4 =>
            _field.`type` match {
              case TType.MAP => {
                aI32Map = readAI32MapValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.MAP

                throw new TProtocolException(
                  "Received wrong type for field 'aI32Map' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 5 =>
            _field.`type` match {
              case TType.MAP => {
                aI64Map = readAI64MapValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.MAP

                throw new TProtocolException(
                  "Received wrong type for field 'aI64Map' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 6 =>
            _field.`type` match {
              case TType.MAP => {
                aDoubleMap = readADoubleMapValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.MAP

                throw new TProtocolException(
                  "Received wrong type for field 'aDoubleMap' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 7 =>
            _field.`type` match {
              case TType.MAP => {
                aStringMap = readAStringMapValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.MAP

                throw new TProtocolException(
                  "Received wrong type for field 'aStringMap' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 8 =>
            _field.`type` match {
              case TType.MAP => {
                aStructMap = readAStructMapValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.MAP

                throw new TProtocolException(
                  "Received wrong type for field 'aStructMap' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 9 =>
            _field.`type` match {
              case TType.MAP => {
                aListMap = readAListMapValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.MAP

                throw new TProtocolException(
                  "Received wrong type for field 'aListMap' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 10 =>
            _field.`type` match {
              case TType.MAP => {
                aSetMap = readASetMapValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.MAP

                throw new TProtocolException(
                  "Received wrong type for field 'aSetMap' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case 11 =>
            _field.`type` match {
              case TType.MAP => {
                aMapMap = readAMapMapValue(_iprot)
              }
              case _actualType =>
                val _expectedType = TType.MAP

                throw new TProtocolException(
                  "Received wrong type for field 'aMapMap' (expected=%s, actual=%s).".format(
                    ttypeToHuman(_expectedType),
                    ttypeToHuman(_actualType)))
            }
          case _ =>
            if (_passthroughFields == null)
              _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
            _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
        }
        _iprot.readFieldEnd()
      }
    }
    _iprot.readStructEnd()

    new Immutable(
      aBoolMap,
      aByteMap,
      aI16Map,
      aI32Map,
      aI64Map,
      aDoubleMap,
      aStringMap,
      aStructMap,
      aListMap,
      aSetMap,
      aMapMap,
      if (_passthroughFields == null)
        NoPassthroughFields
      else
        _passthroughFields.result())
  }

  def apply(
    aBoolMap: Map[Boolean, String] = Map[Boolean, String](),
    aByteMap: Map[Byte, Double] = Map[Byte, Double](),
    aI16Map: Map[Short, Long] = Map[Short, Long](),
    aI32Map: Map[Int, Int] = Map[Int, Int](),
    aI64Map: Map[Long, Short] = Map[Long, Short](),
    aDoubleMap: Map[Double, Byte] = Map[Double, Byte](),
    aStringMap: Map[String, Boolean] = Map[String, Boolean](),
    aStructMap: Map[TestStruct, Seq[String]] = Map[TestStruct, Seq[String]](),
    aListMap: Map[Seq[String], TestStruct] = Map[Seq[String], TestStruct](),
    aSetMap: Map[Set[String], Set[String]] = Map[Set[String], Set[String]](),
    aMapMap: Map[Map[Int, Int], Map[Int, Int]] = Map[Map[Int, Int], Map[Int, Int]]()): TestMaps =
    new Immutable(
      aBoolMap,
      aByteMap,
      aI16Map,
      aI32Map,
      aI64Map,
      aDoubleMap,
      aStringMap,
      aStructMap,
      aListMap,
      aSetMap,
      aMapMap)

  def unapply(_item: TestMaps): Option[scala.Product11[Map[Boolean, String], Map[Byte, Double], Map[Short, Long], Map[Int, Int], Map[Long, Short], Map[Double, Byte], Map[String, Boolean], Map[TestStruct, Seq[String]], Map[Seq[String], TestStruct], Map[Set[String], Set[String]], Map[Map[Int, Int], Map[Int, Int]]]] = Some(_item)

  private def readABoolMapValue(_iprot: TProtocol): Map[Boolean, String] = {
    val _map = _iprot.readMapBegin()
    if (_map.size == 0) {
      _iprot.readMapEnd()
      Map.empty[Boolean, String]
    } else {
      val _rv = new mutable$HashMap[Boolean, String]
      var _i = 0
      while (_i < _map.size) {
        val _key = {
          _iprot.readBool()

        }
        val _value = {
          _iprot.readString()

        }
        _rv(_key) = _value
        _i += 1
      }
      _iprot.readMapEnd()
      _rv
    }
  }

  private def writeABoolMapField(aBoolMap_item: Map[Boolean, String], _oprot: TProtocol) {
    _oprot.writeFieldBegin(ABoolMapField)
    writeABoolMapValue(aBoolMap_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeABoolMapValue(aBoolMap_item: Map[Boolean, String], _oprot: TProtocol) {
    _oprot.writeMapBegin(new TMap(TType.BOOL, TType.STRING, aBoolMap_item.size))
    aBoolMap_item.foreach { _pair =>
      val aBoolMap_item_key = _pair._1
      val aBoolMap_item_value = _pair._2
      _oprot.writeBool(aBoolMap_item_key)
      _oprot.writeString(aBoolMap_item_value)
    }
    _oprot.writeMapEnd()
  }

  private def readAByteMapValue(_iprot: TProtocol): Map[Byte, Double] = {
    val _map = _iprot.readMapBegin()
    if (_map.size == 0) {
      _iprot.readMapEnd()
      Map.empty[Byte, Double]
    } else {
      val _rv = new mutable$HashMap[Byte, Double]
      var _i = 0
      while (_i < _map.size) {
        val _key = {
          _iprot.readByte()

        }
        val _value = {
          _iprot.readDouble()

        }
        _rv(_key) = _value
        _i += 1
      }
      _iprot.readMapEnd()
      _rv
    }
  }

  private def writeAByteMapField(aByteMap_item: Map[Byte, Double], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AByteMapField)
    writeAByteMapValue(aByteMap_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAByteMapValue(aByteMap_item: Map[Byte, Double], _oprot: TProtocol) {
    _oprot.writeMapBegin(new TMap(TType.BYTE, TType.DOUBLE, aByteMap_item.size))
    aByteMap_item.foreach { _pair =>
      val aByteMap_item_key = _pair._1
      val aByteMap_item_value = _pair._2
      _oprot.writeByte(aByteMap_item_key)
      _oprot.writeDouble(aByteMap_item_value)
    }
    _oprot.writeMapEnd()
  }

  private def readAI16MapValue(_iprot: TProtocol): Map[Short, Long] = {
    val _map = _iprot.readMapBegin()
    if (_map.size == 0) {
      _iprot.readMapEnd()
      Map.empty[Short, Long]
    } else {
      val _rv = new mutable$HashMap[Short, Long]
      var _i = 0
      while (_i < _map.size) {
        val _key = {
          _iprot.readI16()

        }
        val _value = {
          _iprot.readI64()

        }
        _rv(_key) = _value
        _i += 1
      }
      _iprot.readMapEnd()
      _rv
    }
  }

  private def writeAI16MapField(aI16Map_item: Map[Short, Long], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AI16MapField)
    writeAI16MapValue(aI16Map_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAI16MapValue(aI16Map_item: Map[Short, Long], _oprot: TProtocol) {
    _oprot.writeMapBegin(new TMap(TType.I16, TType.I64, aI16Map_item.size))
    aI16Map_item.foreach { _pair =>
      val aI16Map_item_key = _pair._1
      val aI16Map_item_value = _pair._2
      _oprot.writeI16(aI16Map_item_key)
      _oprot.writeI64(aI16Map_item_value)
    }
    _oprot.writeMapEnd()
  }

  private def readAI32MapValue(_iprot: TProtocol): Map[Int, Int] = {
    val _map = _iprot.readMapBegin()
    if (_map.size == 0) {
      _iprot.readMapEnd()
      Map.empty[Int, Int]
    } else {
      val _rv = new mutable$HashMap[Int, Int]
      var _i = 0
      while (_i < _map.size) {
        val _key = {
          _iprot.readI32()

        }
        val _value = {
          _iprot.readI32()

        }
        _rv(_key) = _value
        _i += 1
      }
      _iprot.readMapEnd()
      _rv
    }
  }

  private def writeAI32MapField(aI32Map_item: Map[Int, Int], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AI32MapField)
    writeAI32MapValue(aI32Map_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAI32MapValue(aI32Map_item: Map[Int, Int], _oprot: TProtocol) {
    _oprot.writeMapBegin(new TMap(TType.I32, TType.I32, aI32Map_item.size))
    aI32Map_item.foreach { _pair =>
      val aI32Map_item_key = _pair._1
      val aI32Map_item_value = _pair._2
      _oprot.writeI32(aI32Map_item_key)
      _oprot.writeI32(aI32Map_item_value)
    }
    _oprot.writeMapEnd()
  }

  private def readAI64MapValue(_iprot: TProtocol): Map[Long, Short] = {
    val _map = _iprot.readMapBegin()
    if (_map.size == 0) {
      _iprot.readMapEnd()
      Map.empty[Long, Short]
    } else {
      val _rv = new mutable$HashMap[Long, Short]
      var _i = 0
      while (_i < _map.size) {
        val _key = {
          _iprot.readI64()

        }
        val _value = {
          _iprot.readI16()

        }
        _rv(_key) = _value
        _i += 1
      }
      _iprot.readMapEnd()
      _rv
    }
  }

  private def writeAI64MapField(aI64Map_item: Map[Long, Short], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AI64MapField)
    writeAI64MapValue(aI64Map_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAI64MapValue(aI64Map_item: Map[Long, Short], _oprot: TProtocol) {
    _oprot.writeMapBegin(new TMap(TType.I64, TType.I16, aI64Map_item.size))
    aI64Map_item.foreach { _pair =>
      val aI64Map_item_key = _pair._1
      val aI64Map_item_value = _pair._2
      _oprot.writeI64(aI64Map_item_key)
      _oprot.writeI16(aI64Map_item_value)
    }
    _oprot.writeMapEnd()
  }

  private def readADoubleMapValue(_iprot: TProtocol): Map[Double, Byte] = {
    val _map = _iprot.readMapBegin()
    if (_map.size == 0) {
      _iprot.readMapEnd()
      Map.empty[Double, Byte]
    } else {
      val _rv = new mutable$HashMap[Double, Byte]
      var _i = 0
      while (_i < _map.size) {
        val _key = {
          _iprot.readDouble()

        }
        val _value = {
          _iprot.readByte()

        }
        _rv(_key) = _value
        _i += 1
      }
      _iprot.readMapEnd()
      _rv
    }
  }

  private def writeADoubleMapField(aDoubleMap_item: Map[Double, Byte], _oprot: TProtocol) {
    _oprot.writeFieldBegin(ADoubleMapField)
    writeADoubleMapValue(aDoubleMap_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeADoubleMapValue(aDoubleMap_item: Map[Double, Byte], _oprot: TProtocol) {
    _oprot.writeMapBegin(new TMap(TType.DOUBLE, TType.BYTE, aDoubleMap_item.size))
    aDoubleMap_item.foreach { _pair =>
      val aDoubleMap_item_key = _pair._1
      val aDoubleMap_item_value = _pair._2
      _oprot.writeDouble(aDoubleMap_item_key)
      _oprot.writeByte(aDoubleMap_item_value)
    }
    _oprot.writeMapEnd()
  }

  private def readAStringMapValue(_iprot: TProtocol): Map[String, Boolean] = {
    val _map = _iprot.readMapBegin()
    if (_map.size == 0) {
      _iprot.readMapEnd()
      Map.empty[String, Boolean]
    } else {
      val _rv = new mutable$HashMap[String, Boolean]
      var _i = 0
      while (_i < _map.size) {
        val _key = {
          _iprot.readString()

        }
        val _value = {
          _iprot.readBool()

        }
        _rv(_key) = _value
        _i += 1
      }
      _iprot.readMapEnd()
      _rv
    }
  }

  private def writeAStringMapField(aStringMap_item: Map[String, Boolean], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AStringMapField)
    writeAStringMapValue(aStringMap_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAStringMapValue(aStringMap_item: Map[String, Boolean], _oprot: TProtocol) {
    _oprot.writeMapBegin(new TMap(TType.STRING, TType.BOOL, aStringMap_item.size))
    aStringMap_item.foreach { _pair =>
      val aStringMap_item_key = _pair._1
      val aStringMap_item_value = _pair._2
      _oprot.writeString(aStringMap_item_key)
      _oprot.writeBool(aStringMap_item_value)
    }
    _oprot.writeMapEnd()
  }

  private def readAStructMapValue(_iprot: TProtocol): Map[TestStruct, Seq[String]] = {
    val _map = _iprot.readMapBegin()
    if (_map.size == 0) {
      _iprot.readMapEnd()
      Map.empty[TestStruct, Seq[String]]
    } else {
      val _rv = new mutable$HashMap[TestStruct, Seq[String]]
      var _i = 0
      while (_i < _map.size) {
        val _key = {
          TestStruct.decode(_iprot)

        }
        val _value = {
          val _list = _iprot.readListBegin()
          if (_list.size == 0) {
            _iprot.readListEnd()
            Nil
          } else {
            val _rv = new mutable$ArrayBuffer[String](_list.size)
            var _i = 0
            while (_i < _list.size) {
              _rv += {
                _iprot.readString()

              }
              _i += 1
            }
            _iprot.readListEnd()
            _rv
          }

        }
        _rv(_key) = _value
        _i += 1
      }
      _iprot.readMapEnd()
      _rv
    }
  }

  private def writeAStructMapField(aStructMap_item: Map[TestStruct, Seq[String]], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AStructMapField)
    writeAStructMapValue(aStructMap_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAStructMapValue(aStructMap_item: Map[TestStruct, Seq[String]], _oprot: TProtocol) {
    _oprot.writeMapBegin(new TMap(TType.STRUCT, TType.LIST, aStructMap_item.size))
    aStructMap_item.foreach { _pair =>
      val aStructMap_item_key = _pair._1
      val aStructMap_item_value = _pair._2
      aStructMap_item_key.write(_oprot)
      _oprot.writeListBegin(new TList(TType.STRING, aStructMap_item_value.size))
      aStructMap_item_value.foreach { aStructMap_item_value_element =>
        _oprot.writeString(aStructMap_item_value_element)
      }
      _oprot.writeListEnd()
    }
    _oprot.writeMapEnd()
  }

  private def readAListMapValue(_iprot: TProtocol): Map[Seq[String], TestStruct] = {
    val _map = _iprot.readMapBegin()
    if (_map.size == 0) {
      _iprot.readMapEnd()
      Map.empty[Seq[String], TestStruct]
    } else {
      val _rv = new mutable$HashMap[Seq[String], TestStruct]
      var _i = 0
      while (_i < _map.size) {
        val _key = {
          val _list = _iprot.readListBegin()
          if (_list.size == 0) {
            _iprot.readListEnd()
            Nil
          } else {
            val _rv = new mutable$ArrayBuffer[String](_list.size)
            var _i = 0
            while (_i < _list.size) {
              _rv += {
                _iprot.readString()

              }
              _i += 1
            }
            _iprot.readListEnd()
            _rv
          }

        }
        val _value = {
          TestStruct.decode(_iprot)

        }
        _rv(_key) = _value
        _i += 1
      }
      _iprot.readMapEnd()
      _rv
    }
  }

  private def writeAListMapField(aListMap_item: Map[Seq[String], TestStruct], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AListMapField)
    writeAListMapValue(aListMap_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAListMapValue(aListMap_item: Map[Seq[String], TestStruct], _oprot: TProtocol) {
    _oprot.writeMapBegin(new TMap(TType.LIST, TType.STRUCT, aListMap_item.size))
    aListMap_item.foreach { _pair =>
      val aListMap_item_key = _pair._1
      val aListMap_item_value = _pair._2
      _oprot.writeListBegin(new TList(TType.STRING, aListMap_item_key.size))
      aListMap_item_key.foreach { aListMap_item_key_element =>
        _oprot.writeString(aListMap_item_key_element)
      }
      _oprot.writeListEnd()
      aListMap_item_value.write(_oprot)
    }
    _oprot.writeMapEnd()
  }

  private def readASetMapValue(_iprot: TProtocol): Map[Set[String], Set[String]] = {
    val _map = _iprot.readMapBegin()
    if (_map.size == 0) {
      _iprot.readMapEnd()
      Map.empty[Set[String], Set[String]]
    } else {
      val _rv = new mutable$HashMap[Set[String], Set[String]]
      var _i = 0
      while (_i < _map.size) {
        val _key = {
          val _set = _iprot.readSetBegin()
          if (_set.size == 0) {
            _iprot.readSetEnd()
            Set.empty[String]
          } else {
            val _rv = new mutable$HashSet[String]
            var _i = 0
            while (_i < _set.size) {
              _rv += {
                _iprot.readString()

              }
              _i += 1
            }
            _iprot.readSetEnd()
            _rv
          }

        }
        val _value = {
          val _set = _iprot.readSetBegin()
          if (_set.size == 0) {
            _iprot.readSetEnd()
            Set.empty[String]
          } else {
            val _rv = new mutable$HashSet[String]
            var _i = 0
            while (_i < _set.size) {
              _rv += {
                _iprot.readString()

              }
              _i += 1
            }
            _iprot.readSetEnd()
            _rv
          }

        }
        _rv(_key) = _value
        _i += 1
      }
      _iprot.readMapEnd()
      _rv
    }
  }

  private def writeASetMapField(aSetMap_item: Map[Set[String], Set[String]], _oprot: TProtocol) {
    _oprot.writeFieldBegin(ASetMapField)
    writeASetMapValue(aSetMap_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeASetMapValue(aSetMap_item: Map[Set[String], Set[String]], _oprot: TProtocol) {
    _oprot.writeMapBegin(new TMap(TType.SET, TType.SET, aSetMap_item.size))
    aSetMap_item.foreach { _pair =>
      val aSetMap_item_key = _pair._1
      val aSetMap_item_value = _pair._2
      _oprot.writeSetBegin(new TSet(TType.STRING, aSetMap_item_key.size))
      aSetMap_item_key.foreach { aSetMap_item_key_element =>
        _oprot.writeString(aSetMap_item_key_element)
      }
      _oprot.writeSetEnd()
      _oprot.writeSetBegin(new TSet(TType.STRING, aSetMap_item_value.size))
      aSetMap_item_value.foreach { aSetMap_item_value_element =>
        _oprot.writeString(aSetMap_item_value_element)
      }
      _oprot.writeSetEnd()
    }
    _oprot.writeMapEnd()
  }

  private def readAMapMapValue(_iprot: TProtocol): Map[Map[Int, Int], Map[Int, Int]] = {
    val _map = _iprot.readMapBegin()
    if (_map.size == 0) {
      _iprot.readMapEnd()
      Map.empty[Map[Int, Int], Map[Int, Int]]
    } else {
      val _rv = new mutable$HashMap[Map[Int, Int], Map[Int, Int]]
      var _i = 0
      while (_i < _map.size) {
        val _key = {
          val _map = _iprot.readMapBegin()
          if (_map.size == 0) {
            _iprot.readMapEnd()
            Map.empty[Int, Int]
          } else {
            val _rv = new mutable$HashMap[Int, Int]
            var _i = 0
            while (_i < _map.size) {
              val _key = {
                _iprot.readI32()

              }
              val _value = {
                _iprot.readI32()

              }
              _rv(_key) = _value
              _i += 1
            }
            _iprot.readMapEnd()
            _rv
          }

        }
        val _value = {
          val _map = _iprot.readMapBegin()
          if (_map.size == 0) {
            _iprot.readMapEnd()
            Map.empty[Int, Int]
          } else {
            val _rv = new mutable$HashMap[Int, Int]
            var _i = 0
            while (_i < _map.size) {
              val _key = {
                _iprot.readI32()

              }
              val _value = {
                _iprot.readI32()

              }
              _rv(_key) = _value
              _i += 1
            }
            _iprot.readMapEnd()
            _rv
          }

        }
        _rv(_key) = _value
        _i += 1
      }
      _iprot.readMapEnd()
      _rv
    }
  }

  private def writeAMapMapField(aMapMap_item: Map[Map[Int, Int], Map[Int, Int]], _oprot: TProtocol) {
    _oprot.writeFieldBegin(AMapMapField)
    writeAMapMapValue(aMapMap_item, _oprot)
    _oprot.writeFieldEnd()
  }

  private def writeAMapMapValue(aMapMap_item: Map[Map[Int, Int], Map[Int, Int]], _oprot: TProtocol) {
    _oprot.writeMapBegin(new TMap(TType.MAP, TType.MAP, aMapMap_item.size))
    aMapMap_item.foreach { _pair =>
      val aMapMap_item_key = _pair._1
      val aMapMap_item_value = _pair._2
      _oprot.writeMapBegin(new TMap(TType.I32, TType.I32, aMapMap_item_key.size))
      aMapMap_item_key.foreach { _pair =>
        val aMapMap_item_key_key = _pair._1
        val aMapMap_item_key_value = _pair._2
        _oprot.writeI32(aMapMap_item_key_key)
        _oprot.writeI32(aMapMap_item_key_value)
      }
      _oprot.writeMapEnd()
      _oprot.writeMapBegin(new TMap(TType.I32, TType.I32, aMapMap_item_value.size))
      aMapMap_item_value.foreach { _pair =>
        val aMapMap_item_value_key = _pair._1
        val aMapMap_item_value_value = _pair._2
        _oprot.writeI32(aMapMap_item_value_key)
        _oprot.writeI32(aMapMap_item_value_value)
      }
      _oprot.writeMapEnd()
    }
    _oprot.writeMapEnd()
  }

  private def ttypeToHuman(byte: Byte) = {
    // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
    byte match {
      case TType.STOP => "STOP"
      case TType.VOID => "VOID"
      case TType.BOOL => "BOOL"
      case TType.BYTE => "BYTE"
      case TType.DOUBLE => "DOUBLE"
      case TType.I16 => "I16"
      case TType.I32 => "I32"
      case TType.I64 => "I64"
      case TType.STRING => "STRING"
      case TType.STRUCT => "STRUCT"
      case TType.MAP => "MAP"
      case TType.SET => "SET"
      case TType.LIST => "LIST"
      case TType.ENUM => "ENUM"
      case _ => "UNKNOWN"
    }
  }

  object Immutable extends ThriftStructCodec3[TestMaps] {
    override def encode(_item: TestMaps, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): TestMaps = TestMaps.decode(_iprot)
  }

  /**
   * The default read-only implementation of TestMaps.  You typically should not need to
   * directly reference this class; instead, use the TestMaps.apply method to construct
   * new instances.
   */
  class Immutable(
    val aBoolMap: Map[Boolean, String],
    val aByteMap: Map[Byte, Double],
    val aI16Map: Map[Short, Long],
    val aI32Map: Map[Int, Int],
    val aI64Map: Map[Long, Short],
    val aDoubleMap: Map[Double, Byte],
    val aStringMap: Map[String, Boolean],
    val aStructMap: Map[TestStruct, Seq[String]],
    val aListMap: Map[Seq[String], TestStruct],
    val aSetMap: Map[Set[String], Set[String]],
    val aMapMap: Map[Map[Int, Int], Map[Int, Int]],
    override val _passthroughFields: immutable$Map[Short, TFieldBlob]) extends TestMaps {
    def this(
      aBoolMap: Map[Boolean, String] = Map[Boolean, String](),
      aByteMap: Map[Byte, Double] = Map[Byte, Double](),
      aI16Map: Map[Short, Long] = Map[Short, Long](),
      aI32Map: Map[Int, Int] = Map[Int, Int](),
      aI64Map: Map[Long, Short] = Map[Long, Short](),
      aDoubleMap: Map[Double, Byte] = Map[Double, Byte](),
      aStringMap: Map[String, Boolean] = Map[String, Boolean](),
      aStructMap: Map[TestStruct, Seq[String]] = Map[TestStruct, Seq[String]](),
      aListMap: Map[Seq[String], TestStruct] = Map[Seq[String], TestStruct](),
      aSetMap: Map[Set[String], Set[String]] = Map[Set[String], Set[String]](),
      aMapMap: Map[Map[Int, Int], Map[Int, Int]] = Map[Map[Int, Int], Map[Int, Int]]()) = this(
      aBoolMap,
      aByteMap,
      aI16Map,
      aI32Map,
      aI64Map,
      aDoubleMap,
      aStringMap,
      aStructMap,
      aListMap,
      aSetMap,
      aMapMap,
      Map.empty)
  }

  /**
   * This Proxy trait allows you to extend the TestMaps trait with additional state or
   * behavior and implement the read-only methods from TestMaps using an underlying
   * instance.
   */
  trait Proxy extends TestMaps {
    protected def _underlying_TestMaps: TestMaps
    override def aBoolMap: Map[Boolean, String] = _underlying_TestMaps.aBoolMap
    override def aByteMap: Map[Byte, Double] = _underlying_TestMaps.aByteMap
    override def aI16Map: Map[Short, Long] = _underlying_TestMaps.aI16Map
    override def aI32Map: Map[Int, Int] = _underlying_TestMaps.aI32Map
    override def aI64Map: Map[Long, Short] = _underlying_TestMaps.aI64Map
    override def aDoubleMap: Map[Double, Byte] = _underlying_TestMaps.aDoubleMap
    override def aStringMap: Map[String, Boolean] = _underlying_TestMaps.aStringMap
    override def aStructMap: Map[TestStruct, Seq[String]] = _underlying_TestMaps.aStructMap
    override def aListMap: Map[Seq[String], TestStruct] = _underlying_TestMaps.aListMap
    override def aSetMap: Map[Set[String], Set[String]] = _underlying_TestMaps.aSetMap
    override def aMapMap: Map[Map[Int, Int], Map[Int, Int]] = _underlying_TestMaps.aMapMap
    override def _passthroughFields = _underlying_TestMaps._passthroughFields
  }
}

trait TestMaps
  extends ThriftStruct
  with scala.Product11[Map[Boolean, String], Map[Byte, Double], Map[Short, Long], Map[Int, Int], Map[Long, Short], Map[Double, Byte], Map[String, Boolean], Map[TestStruct, Seq[String]], Map[Seq[String], TestStruct], Map[Set[String], Set[String]], Map[Map[Int, Int], Map[Int, Int]]]
  with java.io.Serializable {
  import TestMaps._

  def aBoolMap: Map[Boolean, String]
  def aByteMap: Map[Byte, Double]
  def aI16Map: Map[Short, Long]
  def aI32Map: Map[Int, Int]
  def aI64Map: Map[Long, Short]
  def aDoubleMap: Map[Double, Byte]
  def aStringMap: Map[String, Boolean]
  def aStructMap: Map[TestStruct, Seq[String]]
  def aListMap: Map[Seq[String], TestStruct]
  def aSetMap: Map[Set[String], Set[String]]
  def aMapMap: Map[Map[Int, Int], Map[Int, Int]]

  def _passthroughFields: immutable$Map[Short, TFieldBlob] = immutable$Map.empty

  def _1 = aBoolMap
  def _2 = aByteMap
  def _3 = aI16Map
  def _4 = aI32Map
  def _5 = aI64Map
  def _6 = aDoubleMap
  def _7 = aStringMap
  def _8 = aStructMap
  def _9 = aListMap
  def _10 = aSetMap
  def _11 = aMapMap

  /**
   * Gets a field value encoded as a binary blob using TCompactProtocol.  If the specified field
   * is present in the passthrough map, that value is returend.  Otherwise, if the specified field
   * is known and not optional and set to None, then the field is serialized and returned.
   */
  def getFieldBlob(_fieldId: Short): Option[TFieldBlob] = {
    lazy val _buff = new TMemoryBuffer(32)
    lazy val _oprot = new TCompactProtocol(_buff)
    _passthroughFields.get(_fieldId) orElse {
      val _fieldOpt: Option[TField] =
        _fieldId match {
          case 1 =>
            if (aBoolMap ne null) {
              writeABoolMapValue(aBoolMap, _oprot)
              Some(TestMaps.ABoolMapField)
            } else {
              None
            }
          case 2 =>
            if (aByteMap ne null) {
              writeAByteMapValue(aByteMap, _oprot)
              Some(TestMaps.AByteMapField)
            } else {
              None
            }
          case 3 =>
            if (aI16Map ne null) {
              writeAI16MapValue(aI16Map, _oprot)
              Some(TestMaps.AI16MapField)
            } else {
              None
            }
          case 4 =>
            if (aI32Map ne null) {
              writeAI32MapValue(aI32Map, _oprot)
              Some(TestMaps.AI32MapField)
            } else {
              None
            }
          case 5 =>
            if (aI64Map ne null) {
              writeAI64MapValue(aI64Map, _oprot)
              Some(TestMaps.AI64MapField)
            } else {
              None
            }
          case 6 =>
            if (aDoubleMap ne null) {
              writeADoubleMapValue(aDoubleMap, _oprot)
              Some(TestMaps.ADoubleMapField)
            } else {
              None
            }
          case 7 =>
            if (aStringMap ne null) {
              writeAStringMapValue(aStringMap, _oprot)
              Some(TestMaps.AStringMapField)
            } else {
              None
            }
          case 8 =>
            if (aStructMap ne null) {
              writeAStructMapValue(aStructMap, _oprot)
              Some(TestMaps.AStructMapField)
            } else {
              None
            }
          case 9 =>
            if (aListMap ne null) {
              writeAListMapValue(aListMap, _oprot)
              Some(TestMaps.AListMapField)
            } else {
              None
            }
          case 10 =>
            if (aSetMap ne null) {
              writeASetMapValue(aSetMap, _oprot)
              Some(TestMaps.ASetMapField)
            } else {
              None
            }
          case 11 =>
            if (aMapMap ne null) {
              writeAMapMapValue(aMapMap, _oprot)
              Some(TestMaps.AMapMapField)
            } else {
              None
            }
          case _ => None
        }
      _fieldOpt match {
        case Some(_field) =>
          val _data = Arrays.copyOfRange(_buff.getArray, 0, _buff.length)
          Some(TFieldBlob(_field, _data))
        case None =>
          None
      }
    }
  }

  /**
   * Collects TCompactProtocol-encoded field values according to `getFieldBlob` into a map.
   */
  def getFieldBlobs(ids: TraversableOnce[Short]): immutable$Map[Short, TFieldBlob] =
    (ids flatMap { id => getFieldBlob(id) map { id -> _ } }).toMap

  /**
   * Sets a field using a TCompactProtocol-encoded binary blob.  If the field is a known
   * field, the blob is decoded and the field is set to the decoded value.  If the field
   * is unknown and passthrough fields are enabled, then the blob will be stored in
   * _passthroughFields.
   */
  def setField(_blob: TFieldBlob): TestMaps = {
    var aBoolMap: Map[Boolean, String] = this.aBoolMap
    var aByteMap: Map[Byte, Double] = this.aByteMap
    var aI16Map: Map[Short, Long] = this.aI16Map
    var aI32Map: Map[Int, Int] = this.aI32Map
    var aI64Map: Map[Long, Short] = this.aI64Map
    var aDoubleMap: Map[Double, Byte] = this.aDoubleMap
    var aStringMap: Map[String, Boolean] = this.aStringMap
    var aStructMap: Map[TestStruct, Seq[String]] = this.aStructMap
    var aListMap: Map[Seq[String], TestStruct] = this.aListMap
    var aSetMap: Map[Set[String], Set[String]] = this.aSetMap
    var aMapMap: Map[Map[Int, Int], Map[Int, Int]] = this.aMapMap
    var _passthroughFields = this._passthroughFields
    _blob.id match {
      case 1 =>
        aBoolMap = readABoolMapValue(_blob.read)
      case 2 =>
        aByteMap = readAByteMapValue(_blob.read)
      case 3 =>
        aI16Map = readAI16MapValue(_blob.read)
      case 4 =>
        aI32Map = readAI32MapValue(_blob.read)
      case 5 =>
        aI64Map = readAI64MapValue(_blob.read)
      case 6 =>
        aDoubleMap = readADoubleMapValue(_blob.read)
      case 7 =>
        aStringMap = readAStringMapValue(_blob.read)
      case 8 =>
        aStructMap = readAStructMapValue(_blob.read)
      case 9 =>
        aListMap = readAListMapValue(_blob.read)
      case 10 =>
        aSetMap = readASetMapValue(_blob.read)
      case 11 =>
        aMapMap = readAMapMapValue(_blob.read)
      case _ => _passthroughFields += (_blob.id -> _blob)
    }
    new Immutable(
      aBoolMap,
      aByteMap,
      aI16Map,
      aI32Map,
      aI64Map,
      aDoubleMap,
      aStringMap,
      aStructMap,
      aListMap,
      aSetMap,
      aMapMap,
      _passthroughFields)
  }

  /**
   * If the specified field is optional, it is set to None.  Otherwise, if the field is
   * known, it is reverted to its default value; if the field is unknown, it is subtracked
   * from the passthroughFields map, if present.
   */
  def unsetField(_fieldId: Short): TestMaps = {
    var aBoolMap: Map[Boolean, String] = this.aBoolMap
    var aByteMap: Map[Byte, Double] = this.aByteMap
    var aI16Map: Map[Short, Long] = this.aI16Map
    var aI32Map: Map[Int, Int] = this.aI32Map
    var aI64Map: Map[Long, Short] = this.aI64Map
    var aDoubleMap: Map[Double, Byte] = this.aDoubleMap
    var aStringMap: Map[String, Boolean] = this.aStringMap
    var aStructMap: Map[TestStruct, Seq[String]] = this.aStructMap
    var aListMap: Map[Seq[String], TestStruct] = this.aListMap
    var aSetMap: Map[Set[String], Set[String]] = this.aSetMap
    var aMapMap: Map[Map[Int, Int], Map[Int, Int]] = this.aMapMap

    _fieldId match {
      case 1 =>
        aBoolMap = Map[Boolean, String]()
      case 2 =>
        aByteMap = Map[Byte, Double]()
      case 3 =>
        aI16Map = Map[Short, Long]()
      case 4 =>
        aI32Map = Map[Int, Int]()
      case 5 =>
        aI64Map = Map[Long, Short]()
      case 6 =>
        aDoubleMap = Map[Double, Byte]()
      case 7 =>
        aStringMap = Map[String, Boolean]()
      case 8 =>
        aStructMap = Map[TestStruct, Seq[String]]()
      case 9 =>
        aListMap = Map[Seq[String], TestStruct]()
      case 10 =>
        aSetMap = Map[Set[String], Set[String]]()
      case 11 =>
        aMapMap = Map[Map[Int, Int], Map[Int, Int]]()
      case _ =>
    }
    new Immutable(
      aBoolMap,
      aByteMap,
      aI16Map,
      aI32Map,
      aI64Map,
      aDoubleMap,
      aStringMap,
      aStructMap,
      aListMap,
      aSetMap,
      aMapMap,
      _passthroughFields - _fieldId)
  }

  /**
   * If the specified field is optional, it is set to None.  Otherwise, if the field is
   * known, it is reverted to its default value; if the field is unknown, it is subtracked
   * from the passthroughFields map, if present.
   */
  def unsetABoolMap: TestMaps = unsetField(1)

  def unsetAByteMap: TestMaps = unsetField(2)

  def unsetAI16Map: TestMaps = unsetField(3)

  def unsetAI32Map: TestMaps = unsetField(4)

  def unsetAI64Map: TestMaps = unsetField(5)

  def unsetADoubleMap: TestMaps = unsetField(6)

  def unsetAStringMap: TestMaps = unsetField(7)

  def unsetAStructMap: TestMaps = unsetField(8)

  def unsetAListMap: TestMaps = unsetField(9)

  def unsetASetMap: TestMaps = unsetField(10)

  def unsetAMapMap: TestMaps = unsetField(11)

  override def write(_oprot: TProtocol) {
    TestMaps.validate(this)
    _oprot.writeStructBegin(Struct)
    if (aBoolMap ne null) writeABoolMapField(aBoolMap, _oprot)
    if (aByteMap ne null) writeAByteMapField(aByteMap, _oprot)
    if (aI16Map ne null) writeAI16MapField(aI16Map, _oprot)
    if (aI32Map ne null) writeAI32MapField(aI32Map, _oprot)
    if (aI64Map ne null) writeAI64MapField(aI64Map, _oprot)
    if (aDoubleMap ne null) writeADoubleMapField(aDoubleMap, _oprot)
    if (aStringMap ne null) writeAStringMapField(aStringMap, _oprot)
    if (aStructMap ne null) writeAStructMapField(aStructMap, _oprot)
    if (aListMap ne null) writeAListMapField(aListMap, _oprot)
    if (aSetMap ne null) writeASetMapField(aSetMap, _oprot)
    if (aMapMap ne null) writeAMapMapField(aMapMap, _oprot)
    _passthroughFields.values foreach { _.write(_oprot) }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def copy(
    aBoolMap: Map[Boolean, String] = this.aBoolMap,
    aByteMap: Map[Byte, Double] = this.aByteMap,
    aI16Map: Map[Short, Long] = this.aI16Map,
    aI32Map: Map[Int, Int] = this.aI32Map,
    aI64Map: Map[Long, Short] = this.aI64Map,
    aDoubleMap: Map[Double, Byte] = this.aDoubleMap,
    aStringMap: Map[String, Boolean] = this.aStringMap,
    aStructMap: Map[TestStruct, Seq[String]] = this.aStructMap,
    aListMap: Map[Seq[String], TestStruct] = this.aListMap,
    aSetMap: Map[Set[String], Set[String]] = this.aSetMap,
    aMapMap: Map[Map[Int, Int], Map[Int, Int]] = this.aMapMap,
    _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields): TestMaps =
    new Immutable(
      aBoolMap,
      aByteMap,
      aI16Map,
      aI32Map,
      aI64Map,
      aDoubleMap,
      aStringMap,
      aStructMap,
      aListMap,
      aSetMap,
      aMapMap,
      _passthroughFields)

  override def canEqual(other: Any): Boolean = other.isInstanceOf[TestMaps]

  override def equals(other: Any): Boolean =
    _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
      _passthroughFields == other.asInstanceOf[TestMaps]._passthroughFields

  override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)

  override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)

  override def productArity: Int = 11

  override def productElement(n: Int): Any = n match {
    case 0 => this.aBoolMap
    case 1 => this.aByteMap
    case 2 => this.aI16Map
    case 3 => this.aI32Map
    case 4 => this.aI64Map
    case 5 => this.aDoubleMap
    case 6 => this.aStringMap
    case 7 => this.aStructMap
    case 8 => this.aListMap
    case 9 => this.aSetMap
    case 10 => this.aMapMap
    case _ => throw new IndexOutOfBoundsException(n.toString)
  }

  override def productPrefix: String = "TestMaps"
}