// following were autogenerated by ./codegen/multi_join_generator.rb at Mon Dec 01 19:28:47 -0800 2014 do not edit
package com.twitter.scalding.typed

/**
 * This is an autogenerated object which gives you easy access to
 * doing N-way joins so the types are cleaner. However, it just calls
 * the underlying methods on CoGroupable and flattens the resulting tuple
 */
object MultiJoin extends java.io.Serializable {
  import com.twitter.scalding.typed.FlattenGroup._

  def apply[KEY, A, B](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B]): CoGrouped[KEY, (A, B)] =
    a.join(b)

  def apply[KEY, A, B, C](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C]): CoGrouped[KEY, (A, B, C)] =
    a.join(b)
      .join(c)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D]): CoGrouped[KEY, (A, B, C, D)] =
    a.join(b)
      .join(c)
      .join(d)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E]): CoGrouped[KEY, (A, B, C, D, E)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F]): CoGrouped[KEY, (A, B, C, D, E, F)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G]): CoGrouped[KEY, (A, B, C, D, E, F, G)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H]): CoGrouped[KEY, (A, B, C, D, E, F, G, H)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I, J](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .join(j)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I, J, K](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .join(j)
      .join(k)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I, J, K, L](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .join(j)
      .join(k)
      .join(l)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .join(j)
      .join(k)
      .join(l)
      .join(m)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .join(j)
      .join(k)
      .join(l)
      .join(m)
      .join(n)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .join(j)
      .join(k)
      .join(l)
      .join(m)
      .join(n)
      .join(o)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .join(j)
      .join(k)
      .join(l)
      .join(m)
      .join(n)
      .join(o)
      .join(p)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .join(j)
      .join(k)
      .join(l)
      .join(m)
      .join(n)
      .join(o)
      .join(p)
      .join(q)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .join(j)
      .join(k)
      .join(l)
      .join(m)
      .join(n)
      .join(o)
      .join(p)
      .join(q)
      .join(r)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R], s: CoGroupable[KEY, S]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .join(j)
      .join(k)
      .join(l)
      .join(m)
      .join(n)
      .join(o)
      .join(p)
      .join(q)
      .join(r)
      .join(s)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R], s: CoGroupable[KEY, S], t: CoGroupable[KEY, T]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .join(j)
      .join(k)
      .join(l)
      .join(m)
      .join(n)
      .join(o)
      .join(p)
      .join(q)
      .join(r)
      .join(s)
      .join(t)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R], s: CoGroupable[KEY, S], t: CoGroupable[KEY, T], u: CoGroupable[KEY, U]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .join(j)
      .join(k)
      .join(l)
      .join(m)
      .join(n)
      .join(o)
      .join(p)
      .join(q)
      .join(r)
      .join(s)
      .join(t)
      .join(u)
      .mapValues { tup => flattenNestedTuple(tup) }

  def apply[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R], s: CoGroupable[KEY, S], t: CoGroupable[KEY, T], u: CoGroupable[KEY, U], v: CoGroupable[KEY, V]): CoGrouped[KEY, (A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V)] =
    a.join(b)
      .join(c)
      .join(d)
      .join(e)
      .join(f)
      .join(g)
      .join(h)
      .join(i)
      .join(j)
      .join(k)
      .join(l)
      .join(m)
      .join(n)
      .join(o)
      .join(p)
      .join(q)
      .join(r)
      .join(s)
      .join(t)
      .join(u)
      .join(v)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B]): CoGrouped[KEY, (A, Option[B])] =
    a.leftJoin(b)

  def left[KEY, A, B, C](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C]): CoGrouped[KEY, (A, Option[B], Option[C])] =
    a.leftJoin(b)
      .leftJoin(c)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I, J](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .leftJoin(j)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I, J, K](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .leftJoin(j)
      .leftJoin(k)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I, J, K, L](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .leftJoin(j)
      .leftJoin(k)
      .leftJoin(l)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .leftJoin(j)
      .leftJoin(k)
      .leftJoin(l)
      .leftJoin(m)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .leftJoin(j)
      .leftJoin(k)
      .leftJoin(l)
      .leftJoin(m)
      .leftJoin(n)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .leftJoin(j)
      .leftJoin(k)
      .leftJoin(l)
      .leftJoin(m)
      .leftJoin(n)
      .leftJoin(o)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .leftJoin(j)
      .leftJoin(k)
      .leftJoin(l)
      .leftJoin(m)
      .leftJoin(n)
      .leftJoin(o)
      .leftJoin(p)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .leftJoin(j)
      .leftJoin(k)
      .leftJoin(l)
      .leftJoin(m)
      .leftJoin(n)
      .leftJoin(o)
      .leftJoin(p)
      .leftJoin(q)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .leftJoin(j)
      .leftJoin(k)
      .leftJoin(l)
      .leftJoin(m)
      .leftJoin(n)
      .leftJoin(o)
      .leftJoin(p)
      .leftJoin(q)
      .leftJoin(r)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R], s: CoGroupable[KEY, S]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .leftJoin(j)
      .leftJoin(k)
      .leftJoin(l)
      .leftJoin(m)
      .leftJoin(n)
      .leftJoin(o)
      .leftJoin(p)
      .leftJoin(q)
      .leftJoin(r)
      .leftJoin(s)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R], s: CoGroupable[KEY, S], t: CoGroupable[KEY, T]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S], Option[T])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .leftJoin(j)
      .leftJoin(k)
      .leftJoin(l)
      .leftJoin(m)
      .leftJoin(n)
      .leftJoin(o)
      .leftJoin(p)
      .leftJoin(q)
      .leftJoin(r)
      .leftJoin(s)
      .leftJoin(t)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R], s: CoGroupable[KEY, S], t: CoGroupable[KEY, T], u: CoGroupable[KEY, U]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S], Option[T], Option[U])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .leftJoin(j)
      .leftJoin(k)
      .leftJoin(l)
      .leftJoin(m)
      .leftJoin(n)
      .leftJoin(o)
      .leftJoin(p)
      .leftJoin(q)
      .leftJoin(r)
      .leftJoin(s)
      .leftJoin(t)
      .leftJoin(u)
      .mapValues { tup => flattenNestedTuple(tup) }

  def left[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R], s: CoGroupable[KEY, S], t: CoGroupable[KEY, T], u: CoGroupable[KEY, U], v: CoGroupable[KEY, V]): CoGrouped[KEY, (A, Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S], Option[T], Option[U], Option[V])] =
    a.leftJoin(b)
      .leftJoin(c)
      .leftJoin(d)
      .leftJoin(e)
      .leftJoin(f)
      .leftJoin(g)
      .leftJoin(h)
      .leftJoin(i)
      .leftJoin(j)
      .leftJoin(k)
      .leftJoin(l)
      .leftJoin(m)
      .leftJoin(n)
      .leftJoin(o)
      .leftJoin(p)
      .leftJoin(q)
      .leftJoin(r)
      .leftJoin(s)
      .leftJoin(t)
      .leftJoin(u)
      .leftJoin(v)
      .mapValues { tup => flattenNestedTuple(tup) }

  def outer[KEY, A, B](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B]): CoGrouped[KEY, (Option[A], Option[B])] =
    a.outerJoin(b)

  def outer[KEY, A, B, C](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C]): CoGrouped[KEY, (Option[A], Option[B], Option[C])] =
    a.outerJoin(b)
      .outerJoin(c)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I, J](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .outerJoin(j)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I, J, K](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .outerJoin(j)
      .outerJoin(k)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I, J, K, L](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .outerJoin(j)
      .outerJoin(k)
      .outerJoin(l)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .outerJoin(j)
      .outerJoin(k)
      .outerJoin(l)
      .outerJoin(m)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .outerJoin(j)
      .outerJoin(k)
      .outerJoin(l)
      .outerJoin(m)
      .outerJoin(n)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .outerJoin(j)
      .outerJoin(k)
      .outerJoin(l)
      .outerJoin(m)
      .outerJoin(n)
      .outerJoin(o)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .outerJoin(j)
      .outerJoin(k)
      .outerJoin(l)
      .outerJoin(m)
      .outerJoin(n)
      .outerJoin(o)
      .outerJoin(p)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .outerJoin(j)
      .outerJoin(k)
      .outerJoin(l)
      .outerJoin(m)
      .outerJoin(n)
      .outerJoin(o)
      .outerJoin(p)
      .outerJoin(q)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .outerJoin(j)
      .outerJoin(k)
      .outerJoin(l)
      .outerJoin(m)
      .outerJoin(n)
      .outerJoin(o)
      .outerJoin(p)
      .outerJoin(q)
      .outerJoin(r)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R], s: CoGroupable[KEY, S]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .outerJoin(j)
      .outerJoin(k)
      .outerJoin(l)
      .outerJoin(m)
      .outerJoin(n)
      .outerJoin(o)
      .outerJoin(p)
      .outerJoin(q)
      .outerJoin(r)
      .outerJoin(s)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R], s: CoGroupable[KEY, S], t: CoGroupable[KEY, T]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S], Option[T])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .outerJoin(j)
      .outerJoin(k)
      .outerJoin(l)
      .outerJoin(m)
      .outerJoin(n)
      .outerJoin(o)
      .outerJoin(p)
      .outerJoin(q)
      .outerJoin(r)
      .outerJoin(s)
      .outerJoin(t)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R], s: CoGroupable[KEY, S], t: CoGroupable[KEY, T], u: CoGroupable[KEY, U]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S], Option[T], Option[U])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .outerJoin(j)
      .outerJoin(k)
      .outerJoin(l)
      .outerJoin(m)
      .outerJoin(n)
      .outerJoin(o)
      .outerJoin(p)
      .outerJoin(q)
      .outerJoin(r)
      .outerJoin(s)
      .outerJoin(t)
      .outerJoin(u)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

  def outer[KEY, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V](a: CoGroupable[KEY, A], b: CoGroupable[KEY, B], c: CoGroupable[KEY, C], d: CoGroupable[KEY, D], e: CoGroupable[KEY, E], f: CoGroupable[KEY, F], g: CoGroupable[KEY, G], h: CoGroupable[KEY, H], i: CoGroupable[KEY, I], j: CoGroupable[KEY, J], k: CoGroupable[KEY, K], l: CoGroupable[KEY, L], m: CoGroupable[KEY, M], n: CoGroupable[KEY, N], o: CoGroupable[KEY, O], p: CoGroupable[KEY, P], q: CoGroupable[KEY, Q], r: CoGroupable[KEY, R], s: CoGroupable[KEY, S], t: CoGroupable[KEY, T], u: CoGroupable[KEY, U], v: CoGroupable[KEY, V]): CoGrouped[KEY, (Option[A], Option[B], Option[C], Option[D], Option[E], Option[F], Option[G], Option[H], Option[I], Option[J], Option[K], Option[L], Option[M], Option[N], Option[O], Option[P], Option[Q], Option[R], Option[S], Option[T], Option[U], Option[V])] =
    a.outerJoin(b)
      .outerJoin(c)
      .outerJoin(d)
      .outerJoin(e)
      .outerJoin(f)
      .outerJoin(g)
      .outerJoin(h)
      .outerJoin(i)
      .outerJoin(j)
      .outerJoin(k)
      .outerJoin(l)
      .outerJoin(m)
      .outerJoin(n)
      .outerJoin(o)
      .outerJoin(p)
      .outerJoin(q)
      .outerJoin(r)
      .outerJoin(s)
      .outerJoin(t)
      .outerJoin(u)
      .outerJoin(v)
      .mapValues { tup => flattenNestedOptionTuple(tup) }

}
// end of autogenerated
